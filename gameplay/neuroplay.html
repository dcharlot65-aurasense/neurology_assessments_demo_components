<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroPlay‚Ñ¢ - Gamified Neurological Assessment Platform</title>
    
    <!-- External Dependencies -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
/* ============================================================================
   CSS SECTION - Can be extracted to: css/styles.css
   ============================================================================ */

/* ----------------------------------------------------------------------------
   CSS Variables (css/variables.css)
   ---------------------------------------------------------------------------- */
:root {
    --bg-deep: #0a0a0f;
    --bg-surface: #12121a;
    --bg-elevated: #1a1a25;
    --bg-glass: rgba(26, 26, 37, 0.9);
    --synapse-blue: #00d4ff;
    --synapse-purple: #a855f7;
    --synapse-pink: #ff006e;
    --synapse-green: #00ff88;
    --synapse-gold: #ffd700;
    --text-primary: #ffffff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-muted: rgba(255, 255, 255, 0.4);
}

/* ----------------------------------------------------------------------------
   Base Styles (css/base.css)
   ---------------------------------------------------------------------------- */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Outfit', sans-serif;
    background: var(--bg-deep);
    color: var(--text-primary);
    overflow: hidden;
    min-height: 100vh;
}

.neural-bg {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: -1;
    background: 
        radial-gradient(ellipse at 20% 20%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(168, 85, 247, 0.08) 0%, transparent 50%),
        var(--bg-deep);
}

#app-container { display: flex; width: 100vw; height: 100vh; }

@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

/* ----------------------------------------------------------------------------
   Sidebar Styles (css/sidebar.css)
   ---------------------------------------------------------------------------- */
#sidebar {
    width: 340px;
    background: var(--bg-glass);
    backdrop-filter: blur(20px);
    border-right: 1px solid rgba(0, 212, 255, 0.1);
    display: flex;
    flex-direction: column;
    z-index: 100;
}

.brand { padding: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
.brand h1 {
    font-size: 1.8rem;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.brand span {
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.2em;
}

.connection-panel {
    padding: 14px;
    background: var(--bg-elevated);
    margin: 14px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}
.connection-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.connection-header h3 { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }
.status-indicator { display: flex; align-items: center; gap: 6px; }
.status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--synapse-gold); animation: pulse 2s infinite; }
.status-dot.connected { background: var(--synapse-green); }
.status-text { font-size: 0.65rem; font-family: 'Space Mono', monospace; color: var(--text-muted); }

.connect-btn {
    width: 100%;
    padding: 10px;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    border: none;
    border-radius: 8px;
    color: white;
    font-family: 'Outfit', sans-serif;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 10px;
}
.connect-btn:hover { box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); transform: translateY(-1px); }
.connect-btn.connected { background: linear-gradient(135deg, var(--synapse-green), #00cc6a); }

.demo-notice {
    padding: 8px 10px;
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid var(--synapse-gold);
    border-radius: 8px;
    font-size: 0.7rem;
    color: var(--synapse-gold);
    text-align: center;
}
.demo-notice strong { display: block; margin-bottom: 2px; }

.assessment-menu { flex: 1; overflow-y: auto; padding: 8px 14px; }
.menu-section { margin-bottom: 16px; }
.menu-section h4 {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--synapse-blue);
    padding: 8px 6px;
    margin-bottom: 6px;
    border-bottom: 1px solid rgba(0, 212, 255, 0.2);
}

.assessment-btn {
    width: 100%;
    padding: 10px 12px;
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 10px;
    color: var(--text-primary);
    font-family: 'Outfit', sans-serif;
    font-size: 0.8rem;
    text-align: left;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    gap: 10px;
    min-height: 48px;
}
.assessment-btn:hover { background: rgba(0, 212, 255, 0.1); border-color: var(--synapse-blue); transform: translateX(3px); }
.assessment-btn.active { background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple)); border-color: transparent; }
.assessment-btn .icon {
    width: 28px; height: 28px; min-width: 28px;
    display: flex; align-items: center; justify-content: center;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    font-size: 0.9rem;
}
.assessment-btn .info { flex: 1; min-width: 0; overflow: visible; }
.assessment-btn .title { display: block; font-weight: 500; font-size: 0.8rem; line-height: 1.3; white-space: nowrap; }
.assessment-btn .duration { display: block; font-size: 0.6rem; color: var(--text-muted); font-family: 'Space Mono', monospace; line-height: 1.3; white-space: nowrap; }

.sidebar-footer { padding: 12px 14px; border-top: 1px solid rgba(255, 255, 255, 0.05); margin-top: auto; }
.credit-info { text-align: center; }
.credit-info .designed-by { font-size: 0.65rem; color: var(--text-muted); margin-bottom: 8px; }
.credit-info .designed-by strong { color: var(--synapse-blue); font-weight: 600; }
.credit-info .company-logo { max-width: 160px; height: auto; margin: 8px 0; opacity: 0.9; transition: opacity 0.2s; }
.credit-info .company-logo:hover { opacity: 1; }
.credit-info .contact-email {
    display: block;
    font-size: 0.6rem;
    color: var(--synapse-purple);
    text-decoration: none;
    margin-top: 4px;
    font-family: 'Space Mono', monospace;
    transition: color 0.2s;
}
.credit-info .contact-email:hover { color: var(--synapse-blue); }

/* ----------------------------------------------------------------------------
   Main Content & Top Bar (css/main.css)
   ---------------------------------------------------------------------------- */
#main-content { flex: 1; display: flex; flex-direction: column; position: relative; }

.top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 20px;
    background: var(--bg-glass);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}
.current-assessment { display: flex; align-items: center; gap: 12px; }
.current-assessment h2 { font-size: 1.2rem; font-weight: 500; }

.assessment-tag {
    padding: 3px 10px;
    background: rgba(0, 212, 255, 0.15);
    border: 1px solid var(--synapse-blue);
    border-radius: 20px;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--synapse-blue);
}
.mode-badge {
    padding: 3px 10px;
    background: rgba(255, 215, 0, 0.15);
    border: 1px solid var(--synapse-gold);
    border-radius: 20px;
    font-size: 0.65rem;
    text-transform: uppercase;
    color: var(--synapse-gold);
}

.session-controls { display: flex; gap: 10px; }
.control-btn {
    padding: 8px 16px;
    border-radius: 8px;
    font-family: 'Outfit', sans-serif;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
}
.control-btn.primary { background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple)); color: white; }
.control-btn.primary:hover { box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }
.control-btn.secondary { background: rgba(255, 255, 255, 0.1); color: var(--text-primary); border: 1px solid rgba(255, 255, 255, 0.1); }
.control-btn.secondary:hover { background: rgba(255, 255, 255, 0.15); }
.control-btn.success { background: linear-gradient(135deg, var(--synapse-green), #00cc6a); color: white; }

/* ----------------------------------------------------------------------------
   Game Container & HUD (css/hud.css)
   ---------------------------------------------------------------------------- */
#game-container { flex: 1; position: relative; overflow: hidden; }
#game-canvas { width: 100%; height: 100%; display: block; }

.game-cursor {
    position: absolute;
    width: 24px; height: 24px;
    border: 2px solid var(--synapse-blue);
    border-radius: 50%;
    pointer-events: none;
    z-index: 60;
    transform: translate(-50%, -50%);
    transition: transform 0.1s ease, border-color 0.2s ease;
}
.game-cursor.gripping { border-color: var(--synapse-green); transform: translate(-50%, -50%) scale(0.7); }
.game-cursor::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 4px; height: 4px;
    background: var(--synapse-blue);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}
.game-cursor.gripping::after { background: var(--synapse-green); }

.game-hud { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 50; }
.hud-top-left { position: absolute; top: 16px; left: 16px; }
.hud-top-right { position: absolute; top: 16px; right: 16px; }
.hud-bottom { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); }

.hud-panel {
    background: var(--bg-glass);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 12px 16px;
    pointer-events: auto;
}

.timer-display { display: flex; align-items: center; gap: 10px; }
.timer-display .icon { color: var(--synapse-blue); font-size: 1rem; }
.timer-display .time {
    font-family: 'Space Mono', monospace;
    font-size: 1.6rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.timer-display .label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }

.score-panel { text-align: right; }
.score-panel .score-value { font-family: 'Space Mono', monospace; font-size: 2rem; font-weight: 700; color: var(--synapse-green); }
.score-panel .score-label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }

.metrics-panel { display: flex; gap: 20px; }
.metric { text-align: center; min-width: 70px; }
.metric-value { font-family: 'Space Mono', monospace; font-size: 1.2rem; font-weight: 700; }
.metric-label { font-size: 0.55rem; color: var(--text-muted); text-transform: uppercase; }

.demo-controls { position: absolute; bottom: 16px; left: 16px; pointer-events: auto; }
.demo-controls h4 { font-size: 0.65rem; text-transform: uppercase; color: var(--synapse-gold); margin-bottom: 6px; letter-spacing: 0.1em; }
.control-hints { display: grid; grid-template-columns: auto auto; gap: 4px 12px; font-size: 0.7rem; }
.control-hint { display: flex; align-items: center; gap: 6px; }
.key {
    display: inline-block;
    padding: 2px 6px;
    background: var(--bg-deep);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    min-width: 20px;
    text-align: center;
}

/* Avatar Viewport */
.avatar-viewport-frame {
    position: absolute;
    top: 70px; right: 15px;
    width: 200px; height: 200px;
    border: 2px solid rgba(0, 212, 255, 0.4);
    border-radius: 12px;
    pointer-events: none;
    overflow: hidden;
    background: rgba(18, 18, 26, 0.5);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.2), inset 0 0 30px rgba(0,0,0,0.5);
}
.avatar-viewport-frame::before {
    content: 'DIGITAL TWIN';
    position: absolute;
    top: 8px; left: 50%;
    transform: translateX(-50%);
    font-size: 0.55rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--synapse-blue);
    background: rgba(18, 18, 26, 0.9);
    padding: 2px 10px;
    border-radius: 4px;
    z-index: 10;
}
.avatar-viewport-frame.hidden { display: none; }

/* Hand Visualization */
.hand-viz-container { position: absolute; bottom: 16px; right: 16px; display: flex; gap: 12px; pointer-events: none; }
.hand-viz {
    width: 160px;
    padding: 10px;
    background: var(--bg-glass);
    backdrop-filter: blur(15px);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
.hand-viz-title {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
}
.hand-viz-title .grip-state { color: var(--synapse-green); font-family: 'Space Mono', monospace; }

.finger-bars { display: flex; gap: 3px; height: 40px; align-items: flex-end; }
.finger-bar { flex: 1; background: rgba(255, 255, 255, 0.1); border-radius: 2px; position: relative; overflow: hidden; }
.finger-bar-fill {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    transition: height 0.1s ease;
    border-radius: 2px;
}
.finger-labels { display: flex; gap: 3px; margin-top: 3px; }
.finger-labels span { flex: 1; text-align: center; font-size: 0.45rem; color: var(--text-muted); font-family: 'Space Mono', monospace; }

/* ----------------------------------------------------------------------------
   Overlays & Modals (css/overlays.css)
   ---------------------------------------------------------------------------- */
.overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10, 10, 15, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
}
.overlay.visible { opacity: 1; pointer-events: auto; }

.overlay-card {
    max-width: 550px;
    width: 90%;
    padding: 40px;
    background: var(--bg-elevated);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
}
.overlay-card .icon { font-size: 3.5rem; margin-bottom: 20px; }
.overlay-card h2 {
    font-size: 1.6rem;
    font-weight: 600;
    margin-bottom: 12px;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.overlay-card p { color: var(--text-secondary); line-height: 1.6; margin-bottom: 20px; font-size: 0.9rem; }
.overlay-card .clinical-ref {
    display: inline-block;
    padding: 5px 14px;
    background: rgba(0, 212, 255, 0.1);
    border: 1px solid var(--synapse-blue);
    border-radius: 20px;
    font-size: 0.7rem;
    color: var(--synapse-blue);
    margin-bottom: 20px;
}
.overlay-card .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
.overlay-card .start-btn {
    padding: 14px 36px;
    font-size: 0.95rem;
    background: linear-gradient(135deg, var(--synapse-blue), var(--synapse-purple));
    border: none;
    border-radius: 10px;
    color: white;
    font-family: 'Outfit', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}
.overlay-card .start-btn:hover { box-shadow: 0 0 25px rgba(0, 212, 255, 0.5); transform: scale(1.03); }
.overlay-card .demo-btn {
    padding: 14px 28px;
    font-size: 0.95rem;
    background: rgba(255, 215, 0, 0.15);
    border: 1px solid var(--synapse-gold);
    border-radius: 10px;
    color: var(--synapse-gold);
    font-family: 'Outfit', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}
.overlay-card .demo-btn:hover { background: rgba(255, 215, 0, 0.25); }

/* Results Grid */
.results-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
.result-item { padding: 14px; background: var(--bg-deep); border-radius: 10px; text-align: center; }
.result-item .value { font-family: 'Space Mono', monospace; font-size: 1.5rem; font-weight: 700; margin-bottom: 4px; }
.result-item .label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }
.result-item.primary .value { color: var(--synapse-blue); }
.result-item.success .value { color: var(--synapse-green); }
.result-item.warning .value { color: var(--synapse-gold); }

.clinical-interpretation {
    padding: 14px 16px;
    background: rgba(0, 212, 255, 0.1);
    border: 1px solid var(--synapse-blue);
    border-radius: 10px;
    margin-bottom: 16px;
    text-align: left;
}
.clinical-interpretation h4 { font-size: 0.65rem; text-transform: uppercase; color: var(--synapse-blue); margin-bottom: 6px; }
.clinical-interpretation p { color: var(--text-secondary); font-size: 0.8rem; line-height: 1.5; margin-bottom: 0; }
.results-actions { display: flex; gap: 10px; justify-content: center; }

/* Connection Modal */
.connection-modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10, 10, 15, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.connection-modal.visible { opacity: 1; pointer-events: auto; }
.connection-modal .modal-content {
    max-width: 450px;
    width: 90%;
    padding: 32px;
    background: var(--bg-elevated);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
.connection-modal h3 { font-size: 1.3rem; margin-bottom: 6px; text-align: center; }
.connection-modal .subtitle { text-align: center; color: var(--text-muted); margin-bottom: 20px; font-size: 0.85rem; }
.connection-modal .input-group { margin-bottom: 16px; }
.connection-modal label { display: block; font-size: 0.7rem; text-transform: uppercase; color: var(--text-muted); margin-bottom: 6px; }
.connection-modal input {
    width: 100%;
    padding: 10px 14px;
    background: var(--bg-deep);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: white;
    font-family: 'Space Mono', monospace;
    font-size: 0.85rem;
}
.connection-modal input:focus { outline: none; border-color: var(--synapse-blue); }
.connection-modal .modal-actions { display: flex; gap: 10px; }
.connection-modal .modal-actions button { flex: 1; }

.connection-status-msg { padding: 10px; border-radius: 8px; font-size: 0.8rem; text-align: center; margin-bottom: 14px; }
.connection-status-msg.error { background: rgba(255, 0, 110, 0.1); border: 1px solid var(--synapse-pink); color: var(--synapse-pink); }
.connection-status-msg.success { background: rgba(0, 255, 136, 0.1); border: 1px solid var(--synapse-green); color: var(--synapse-green); }

/* ============================================================================
   END CSS SECTION
   ============================================================================ */
    </style>
</head>
<body>
    <div class="neural-bg"></div>
    <div id="app-container">
        <nav id="sidebar">
            <div class="brand"><h1>NeuroPlay‚Ñ¢</h1><span>Clinical Assessment Platform</span></div>
            <div class="connection-panel">
                <div class="connection-header">
                    <h3>Controller Status</h3>
                    <div class="status-indicator"><div class="status-dot" id="connection-dot"></div><span class="status-text" id="connection-status">Demo Mode</span></div>
                </div>
                <button class="connect-btn" id="btn-connect">üéÆ Connect etee Controllers</button>
                <div class="demo-notice" id="demo-notice"><strong>Demo Mode Active</strong>Use mouse & keyboard to test</div>
            </div>
            <div class="assessment-menu">
                <div class="menu-section">
                    <h4>üéØ Motor Dexterity</h4>
                    <button class="assessment-btn active" data-assessment="pegboard"><div class="icon">üìç</div><div class="info"><span class="title">Virtual Pegboard</span><span class="duration">~2 min ‚Ä¢ 9-Hole Peg Test</span></div></button>
                    <button class="assessment-btn" data-assessment="fingertap"><div class="icon">üëÜ</div><div class="info"><span class="title">Finger Tapping</span><span class="duration">~1 min ‚Ä¢ UPDRS 3.4</span></div></button>
                    <button class="assessment-btn" data-assessment="boxblock"><div class="icon">üì¶</div><div class="info"><span class="title">Box & Blocks</span><span class="duration">~1 min ‚Ä¢ BBT</span></div></button>
                    <button class="assessment-btn" data-assessment="purdue"><div class="icon">üîß</div><div class="info"><span class="title">Purdue Pegboard</span><span class="duration">~2 min ‚Ä¢ Bimanual</span></div></button>
                    <button class="assessment-btn" data-assessment="gripforce"><div class="icon">‚úä</div><div class="info"><span class="title">Grip Force</span><span class="duration">~1 min ‚Ä¢ Force Control</span></div></button>
                    <button class="assessment-btn" data-assessment="fingerseq"><div class="icon">üñêÔ∏è</div><div class="info"><span class="title">Finger Sequence</span><span class="duration">~2 min ‚Ä¢ Luria</span></div></button>
                </div>
                <div class="menu-section">
                    <h4>üß† Cognitive Function</h4>
                    <button class="assessment-btn" data-assessment="trailmaking"><div class="icon">üîó</div><div class="info"><span class="title">Trail Making</span><span class="duration">~3 min ‚Ä¢ TMT-A/B</span></div></button>
                    <button class="assessment-btn" data-assessment="reactiontime"><div class="icon">‚ö°</div><div class="info"><span class="title">Reaction Time</span><span class="duration">~2 min ‚Ä¢ Processing Speed</span></div></button>
                    <button class="assessment-btn" data-assessment="gonogo"><div class="icon">üö¶</div><div class="info"><span class="title">Go/No-Go</span><span class="duration">~2 min ‚Ä¢ Inhibition</span></div></button>
                    <button class="assessment-btn" data-assessment="nback"><div class="icon">üß†</div><div class="info"><span class="title">N-Back</span><span class="duration">~3 min ‚Ä¢ Working Memory</span></div></button>
                    <button class="assessment-btn" data-assessment="symboldigit"><div class="icon">üî¢</div><div class="info"><span class="title">Symbol Digit</span><span class="duration">~2 min ‚Ä¢ SDMT</span></div></button>
                    <button class="assessment-btn" data-assessment="stroop"><div class="icon">üé®</div><div class="info"><span class="title">Stroop Test</span><span class="duration">~2 min ‚Ä¢ Interference</span></div></button>
                </div>
                <div class="menu-section">
                    <h4>üìä Movement Analysis</h4>
                    <button class="assessment-btn" data-assessment="tremor"><div class="icon">„Ä∞Ô∏è</div><div class="info"><span class="title">Tremor Analysis</span><span class="duration">~30s ‚Ä¢ IMU Tracking</span></div></button>
                    <button class="assessment-btn" data-assessment="spiral"><div class="icon">üåÄ</div><div class="info"><span class="title">Spiral Drawing</span><span class="duration">~1 min ‚Ä¢ Bradykinesia</span></div></button>
                    <button class="assessment-btn" data-assessment="pronation"><div class="icon">üîÑ</div><div class="info"><span class="title">Pronation/Supination</span><span class="duration">~30s ‚Ä¢ UPDRS 3.6</span></div></button>
                    <button class="assessment-btn" data-assessment="posturalsway"><div class="icon">‚öñÔ∏è</div><div class="info"><span class="title">Postural Sway</span><span class="duration">~30s ‚Ä¢ Balance</span></div></button>
                    <button class="assessment-btn" data-assessment="coordination"><div class="icon">üéÆ</div><div class="info"><span class="title">Coordination</span><span class="duration">~30s ‚Ä¢ Bimanual</span></div></button>
                </div>
                <div class="menu-section">
                    <h4>‚öîÔ∏è Gamified Assessment</h4>
                    <button class="assessment-btn" data-assessment="rhythmslash"><div class="icon">‚öîÔ∏è</div><div class="info"><span class="title">Rhythm Slasher</span><span class="duration">~20s ‚Ä¢ Multi-Domain</span></div></button>
                    <button class="assessment-btn" data-assessment="colorsort"><div class="icon">üßä</div><div class="info"><span class="title">Color Sort</span><span class="duration">~60s ‚Ä¢ Memory + Attention</span></div></button>
                    <button class="assessment-btn" data-assessment="memorymatch"><div class="icon">üÉè</div><div class="info"><span class="title">Memory Match</span><span class="duration">~90s ‚Ä¢ Visual Memory</span></div></button>
                    <button class="assessment-btn" data-assessment="towerstack"><div class="icon">üèóÔ∏è</div><div class="info"><span class="title">Tower Stack</span><span class="duration">~45s ‚Ä¢ Motor Planning</span></div></button>
                    <button class="assessment-btn" data-assessment="patternrunner"><div class="icon">üî¢</div><div class="info"><span class="title">Pattern Runner</span><span class="duration">~60s ‚Ä¢ Procedural Memory</span></div></button>
                    <button class="assessment-btn" data-assessment="whackamole"><div class="icon">üî®</div><div class="info"><span class="title">Whack-a-Mole</span><span class="duration">~45s ‚Ä¢ Attention + RT</span></div></button>
                    <button class="assessment-btn" data-assessment="balanceboard"><div class="icon">‚öñÔ∏è</div><div class="info"><span class="title">Balance Board</span><span class="duration">~60s ‚Ä¢ Postural Control</span></div></button>
                </div>
            </div>
            <div class="sidebar-footer">
                <div class="credit-info">
                    <div class="designed-by">Designed by <strong>David Charlot</strong></div>
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJ4AAAAyCAIAAAAiOfW5AAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfpDAgSDxR/O5qoAAARsklEQVR42u1beZCdVZU/59z7bW/r7nQnECJJNwGC7JAIJCgkKKCOIQwqS0hANGAQtKZcgDjWMC6oNWVpleU44jCCiCgKCs5oSNhCEpKQkK2z7wkh3Vl6e/u33Xvmj++916/XNGVNMXS9X3316uv+zjvnfvd3zz3nntONM66aAzWMRtB7PYAa/q9Qo3bUokbtqEWN2lGLGrWjFjVqRy1q1I5a1KgdtahRO2pRo3bUYqTU8ns90BreLU5CLQMAMwMAlu7f6wHXMFIMRy0DIDMTomJyFTIzYo3d9wuGpLbEq0BylWowOm8/XZuEmhnxvR5zDSPC4NSWeSVylaq3Ou862zgRkKtZYmVnrjnv/3PIgb+q4jVQKbvj7kti64+kFrexRPQBGNgWLDDy4JO6MDMjIhEN9TRaJGUxVEoP1MrMkQatNSIOpVNrPbw5ANaauTLwKMQgDZ4mMpcslcRwKBmo1gYACMDQ+/vKlCJC+aasM5KG/gPggWKDvk0fKyehti+vTufdV8Y2HEwtPqDjZu4jp3otjnE0l3y1A31m4+TsRsPTWmeyuYFBmgFMw4jFnEhMKVUo+NGPAFBRHD0tFl0iMk0jojkMw/46ERPxGBExcyaT1VoPHI8QIh6PlWYMgIkwDDDwBxs7smkxETIzEYZhWazP67KUbBioNQCUmAtCYGbTiIiBajpDBQAsRYU2dEOIZCrvgQAMLIkNUVkN5CrQAxYfobZEhf6BLGD1X1lUeEXX16l414Jr7U17UotbtWN2zbuAbR1ffaRwcUqlRNNjhzAYEbta61jMuXL6NGlI1lVLjJkE7d//9ubW7Y5jK6Xq61LNzadvbt0+0OeCIDj3g2fncvm3Dx+xLKtQLI5pqL/8Q5eYlsGaAQAJgyBcteqtfKFgSDl9+rRUMqGU6mtOHD16fO26TVIKImJA9F095pRgQkv57as/2Ti4h4oFFgJ9XyeSwcRmEATMgL2S8uhRcfwEm2bEH4RhOK6JDWm0nwDCCrsMgEqrhgQAiO4cS8JQsyS/ZZy2JTJX22WB8ljOOJplSagYALyWOp0wgHVJhgEIKOtbB/KAwISD+m6v1/bn9QtznI07kks2a8fsnn8Z6qDxlxsoF8RXn+icP6njnklNvzw5u4gYBOHYsY3f+NqXpBQDA3Qs5vzX47//j0d/HYTq2o9e/OAD9/3DDfN9P6hmFxFd13vwG1/aum3Xv373x0R05hnNP//Z9xvq64pFFwmBAQkDP7h79wPde9PJZOK+e+88bfwpvh9Uj4uZ4/HY0peXf+tf/o2EJL/on3VRds5CVC6ogCGaX136FJh69leUzyLrcPyE9M13gCHQdxkBQJcuBHasxF8X25u3sG2D5+evubJwxcVAbG3bk3r+FZCivEUjen5u1sUAXP+7ZSwsto3u264MxtdRvghU0cmgtY6J+JuHzHfSLAkQuj9zjntOg8i6QL0jZK1VSjjbehqeOxxtGAPnX/bhlQS6rk4mu++6zdm0Jblkrbat7nkzQQdjfrMGNOenT6C83/jkoc47JnXc09z06MHh2dVaW5Z56NA7n5g9TwhRHVGIKJ8v3HjDx7/50JdfXPJa69YdQhAhRgt94BJBREIkRNf1Ft4zr7s7fdNnFnBp32YAVEoppRzHzuXyc+ffL6WsNodIrutedNF5j/77D/+2+JVlr69Oxuz8NbeaO99KLH6CTRt6XQcAEFijUmyYVCzkZ14vOjvqf/84C9FnTJ6Xn3V1/qMzrV170PPU2Mb8jGl1f15M6Wz3gk/b2/ZYOw9o20KtGRGgHK0JyQ1yM6aoMYmxP12Crg+E/UItKq1tScWwcMkp3tmNYx/dKE8UWFJJDAFDHZzqnLh7srO1x9mS1o4YmC1QFa+EnquTqZ67FtituxJLlmvb7Ln9E6hlw1MrIQgznzw/+9EpPf84JXPdxKYnDhhHvI4vNrMEDDjaEwamIlEgICKllO/7vh9ULs/zldIrV61TSjU1jVGhigiEIYCIUNY2YcL4tes2trUf01p7nl/WpqJAG30ONAeAGza0dnX1nHbaqWEQgGWzFTP3bkbPBRViGGAYlq8AtWIiYGYhOVln7duF+RwwV2RAKQxDc89eEFI7DoZKWxZ5vjxy1Nq1327dnb/6Q1EZYJDjIrNqSBjvdMsTGWDAQGPY54r4A82qwZEnCsY7WQDoJ2AeLshOXzWYg4ThCrUlXgNfp+p7Pvdlu3VrcslStq2euTcBi/rfvoRekJl9mTfl9KZfrG789ZbczJb0x5ubHt9fYtdADEp5wVDEGIakkk9irwtSxBeWPWXEYLBMyzRNIhKCKp+VxSSEEEL0MUdYsk+VjBOBAZBYCCDBou9FVQmmUmyYIGUkHF1AxEJEGVApz2VmIDYMtq3YyvXBqU3+lGby/L5RsDeFBgAWBIJYYJ9LEpcTK1TMRGwKJmQqC0T3UV4/9BmUINqptWLDytz6FXtra3zpf+tYPD13HrKsf+oF8vzs7Kv8s5obH1tGOddoyzQ9tik3syVzfXPjkweNNr/jC5Mqe/KA1Vnap3vS2SDoE/kAMQzVtEsvJKLOzm4hxbs4KGPl1MQDLRJRNptzXbffHuD7/rkfPLuhvq6t/aiQEgIPWauxH0DfRa+AbhHdIkWfxQK5+V6dtoNBgMUC+h56LnpedJHrhuPGASL6Zf4QUDObhtF2wt62t+K4ZUWVnA6o6IdNKZZEeY/ckNyA3IDckNyQ8j5qHS1SbQpApLxPnupzFUKdMFS9SXk17OEHCYs597KPU64Yf+lZtp3cJz+NIaT+8AdAzNxwvXfmhIbHnxMdPfkPnwfA8VW7m/5zY+fnLjQOZxt/c+j4vZOzM5vq/nqU47J/zEAEAM/3771n/m233FiJi2UWoL4+tXrN+sPvtFmmyfrvrYJEvBYKxTmzr7vv3s/ZtsVcMQfMur6+7u23j7Ru2eHEY+y59uq/5q+f70++AFUAxAwMzIAaWFtb3rQ3rWLDBABr68Zg0uTuL35VWxaCgkrChRCMPyW+bBnm8yxE2R8BmNmQ8RXrOxfe4k9ptnYe0DG7z6q0TOetvcXzJ3b806eoJ8cSATQwI2gmMNp7Eq/tITfUprAO9gSn13V+/mKVMkBrwMguo9LBOMs4VrR3ptmmQX1XVmYFpIlBADoEksFpk2MrXqRMj3f+hcGE0xue/JM83lWYcVHuY1Pr/vgqILBhIFtAyMixTZnCJQ3l5dhnXyWidDp782c/de8X7/jVE88cP35CSllOBSBUKp8rLHro/gvOP+fVZauQ/t4SZsTr1Esv+PbDX3/+L0u2b99tWmYpB2AmoiNtR//5oa9cM+vK3z/zQn1Dvb3hFdFzLGg5r7K1MTCwYsvJfeJWALA3rAQAymaDKyZbG9dI3wVEQC7lXAix5a+be/ayZaFfdThmZtOU7SfsrXvzV08zdx0E5t7KBANLEl25MY+/4l44SduyfKBiAAal3YvGh2NiY556CwhFtxuMixtHs/auLpZY/j4Dgb2lM7a5CwPNgoY+/LBmO2ZtW+VOu644Y05s+XPxl/+SmzOfijlz7/b6o8dET09h+tTcdVfWP/2CtfOQf9aErjs+nFy6yTzYo2Myf8UH7J0d5TXZH0qpmVfPWLlq3cPf+VFDfb3WquzQ5HleS8vEmOMIIaqKDzhoAMERxGIidD1v+hVT29qOPrjoEcOQvdoQtdaGlA9/66umYTAzMLNhGftazV3r+wycCAs5AO1deLmzfgUTudNm2G+tTv35KR1PgNZ9hIXQllXirHoCmFnK+Mr1nQtv9s9pNncehChJLsVYYFOIdCHxcmvfl0TyQndHe9fnrwib4uah7vyMiaih8YnNqHSfeMcAhGyJiNchDz/IzEJiLp389ieZuYtA6/jrfwQpMzctSP3pMXvz2vxHZuWunVX3u2esXQf9Myd2z7s2+dK6+Jr92jK6508VhSCxop1jctBtARGkEPl8oXFMQ2PjGKUq1KLv+4lErPIbANCsETFKgioZNxERkeZBqkuDQkrpel4qlUwm47q8yUe5qtasWZealNEUOYn+oyYiJMrnFFKpDKmZ3IJKprhEbf/FO0g3jJlNo+S4V00zdx/qlSm7LxuCzb7VQAS2NQYafcVSAAMIokLABumEOYgVzcMUFSSU0ijNliPbD6Se/n5m7jcBIf7aHwAxO/sO79xL/cnNdc/8ztq91z9jUs+8GxOvvhFfvUPbZvftHwYIx/xmPUuKTlAwSCYFSinTNDq7upm5Uv9DomKhWF+fEkKESiGiCpUUslgsptNZw5AVahExXyhKKcNQVeZtmPaEUso0zUwm67pu9RJTSlmWaUgZqrCkNyhioSqD5RK1WMixHSstemAgYiEpl9EA2I9aBjYMNozoHqsflhx3Q+fCm/2zJsXe2ASIjFE9C1BpLAQD/QC9EMbG2RCodMnJDYFuiL7qU48srUJkk0qzPOiGjOUkWceSsv1g6ukfZOZ+Exhirz+LxYJ70WWpZ5829+0MJrWkb78tvmx5fNUmbVs9cz8GqMY8uYLlcN0CIWjFyrUPPXDfogfuP368QxpGVL9FRNfzbrzh+hMdXfv2HUzVJbds3QEAj3znwWWvr44yIAYgRM/3zzqz5czJzT/7+eOmaTIzIQ0amJnZMs031268685bvv3w17Zv32NZpq4yN/3yqY7jbNq8zXZs8L1g0rlB83kYlsNkFPBYacspTr0q8fJzjAhKG/t2Fi+/mrJpDH3GSrzgqHgn29tkRwcgMJG27coUY8VxW3dnbpgZnNroTmlOvrwWiFBpHbeLM84FgkrYjsphqFTx0tON9ozsyGvHMPd3Za85Iz3ng+bhHjYIqkuSBJQPrH0ZGL4aVWJXhTqWrPguAjsrnzf3bQWlgg8099y+ILbylfgba7Rt99w2G1A3PPk/LOUwvGqtk8nEc8//bdy4xjvnf7YfDUKK9vbjX3/wu+l0NhGPvX34yAOLvvfQN+6fMX2a0rpXG4IK1Y9+/IvlK99MJOLpdGb/gbfb2o6RoH6uq5SOx2Nr12165Ic/vW/hnTd86rqKczMAEeZy+UXf+sGevQfiiYQu5NS4if6509ErAEI56WUGBtDxV5+317/OpoXMsRVL2TALV10HOowEMPJQrbRjxVauMNrb2TCoULB37EbXA6TIBaO1lnhlTQ7BPf/MxPKNsXU7tG1iqLRtuudNqi5tMpYz5CPp5EvbgZlNaRxO1/9pW3ZWi3teE7CuDBJYswHyeME8kB2qiT5oe0BSIRuOb8nMXeS88YK97sXwtDMyn13grFkaW76UbTt96y1Muv6pP8KwvEL5XMvM+XwhFnOMyGUruSJiLpdHRMextdZElC8UBFEsFquIMUcVPd913UQiDlW7cWSzn+Wo+pLLFUzLdCxLV+khxEKxGIYqHo/p6OAY+sA8SPLHjFpr2ynNkdYY+NqygWhgwEOlADEKaqAUSNnb8yl3vtAPmAg1s2WUGkRKg9LQ5zRYVhhqNnvzI/LCqBHU3zRC1DyobjENSW1/dk87Izd7ISjFjmWvXeysepFNO33rnSC47qlfgzRG0rWtNFCVUgMDpBACqrqwQpDWPLAfF+VWlXZsP+X9zEVqBzUXZWRKKRyqBFhlstSLjbp1EXOVM0y1RSxX9KIyV6XVWt2mjQoX/XQOabpvvzbqf2ge5OiAQ/I6CLW97JJAv8iGpU5ppkyH6DrGUmZu+RILrvvtL0BKFiIqfI+wGz+Sp8NIVh4NvHlXFvv34Yee3n7fGeYFK5M72A7Q+/V+EjwChScf58hb8VCVVbFpo9by8C4Qgi0ne9P9ILDu6Z+8K15hwJ45zNOTtAeGuHlXFnsfjWzwI5Icvgze5w1hsNshFY5k+oZ6MvgfmpSCmNaMyHYMA68w6xY2Y6nf/hjEu+O1hvcKcriHUcDQik3b2vSak+kEIWq8vl9w8v8eiOKu6GxHrVnIGq/vF8iTSpTyNGlAOWjXeH1f4OTU9jk81mh9/6D2n3qjFjVqRy1q1I5a1KgdtahRO2pRo3bUokbtqEWN2lGLGrWjFjVqRy3+F2oIr27pxSN0AAAAAElFTkSuQmCC" alt="AuraSense" class="company-logo" />
                    <a href="/cdn-cgi/l/email-protection#eb8f8a9d828fab8a9e998a988e85988ec58a82" class="contact-email"><span class="__cf_email__" data-cfemail="fb9f9a8d929fbb9a8e899a889e95889ed59a92">[email&#160;protected]</span></a>
                </div>
            </div>
        </nav>
        <main id="main-content">
            <div class="top-bar">
                <div class="current-assessment">
                    <h2 id="assessment-title">Virtual Pegboard</h2>
                    <span class="assessment-tag" id="assessment-tag">Motor Dexterity</span>
                    <span class="mode-badge" id="mode-badge">Demo Mode</span>
                </div>
                <div class="session-controls">
                    <button class="control-btn secondary" id="btn-avatar" title="Toggle Digital Twin">üßç Avatar</button>
                    <button class="control-btn secondary" id="btn-instructions">Instructions</button>
                    <button class="control-btn success" id="btn-demo">‚ñ∂ Watch Demo</button>
                    <button class="control-btn primary" id="btn-start">Start Assessment</button>
                </div>
            </div>
            <div id="game-container">
                <canvas id="game-canvas"></canvas>
                <div class="game-cursor" id="game-cursor"></div>
                <div class="avatar-viewport-frame" id="avatar-frame"></div>
                <div class="game-hud" id="game-hud" style="display: none;">
                    <div class="hud-top-left"><div class="hud-panel timer-display"><span class="icon">‚è±</span><div><div class="time" id="timer">00:00</div><div class="label">Time</div></div></div></div>
                    <div class="hud-top-right"><div class="hud-panel score-panel"><div class="score-value" id="score">0</div><div class="score-label" id="score-label">Score</div></div></div>
                    <div class="hud-bottom"><div class="hud-panel metrics-panel">
                        <div class="metric"><div class="metric-value" id="metric-1">--</div><div class="metric-label" id="metric-1-label">Completed</div></div>
                        <div class="metric"><div class="metric-value" id="metric-2">--</div><div class="metric-label" id="metric-2-label">Accuracy</div></div>
                        <div class="metric"><div class="metric-value" id="metric-3">--</div><div class="metric-label" id="metric-3-label">Avg Time</div></div>
                    </div></div>
                    <div class="demo-controls" id="demo-controls"><div class="hud-panel"><h4>üéÆ Demo Controls</h4><div class="control-hints">
                        <div class="control-hint"><span class="key">Mouse</span> Move</div>
                        <div class="control-hint"><span class="key">Click</span> Grip</div>
                        <div class="control-hint"><span class="key">Space</span> Both</div>
                        <div class="control-hint"><span class="key">Esc</span> Stop</div>
                    </div></div></div>
                    <div class="hand-viz-container">
                        <div class="hand-viz"><div class="hand-viz-title"><span>LEFT</span><span class="grip-state" id="left-grip-state">OPEN</span></div><div class="finger-bars"><div class="finger-bar"><div class="finger-bar-fill" id="left-thumb"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="left-index"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="left-middle"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="left-ring"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="left-pinky"></div></div></div><div class="finger-labels"><span>TH</span><span>IN</span><span>MD</span><span>RN</span><span>PK</span></div></div>
                        <div class="hand-viz"><div class="hand-viz-title"><span>RIGHT</span><span class="grip-state" id="right-grip-state">OPEN</span></div><div class="finger-bars"><div class="finger-bar"><div class="finger-bar-fill" id="right-thumb"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="right-index"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="right-middle"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="right-ring"></div></div><div class="finger-bar"><div class="finger-bar-fill" id="right-pinky"></div></div></div><div class="finger-labels"><span>TH</span><span>IN</span><span>MD</span><span>RN</span><span>PK</span></div></div>
                    </div>
                </div>
                <div class="overlay" id="instructions-overlay"><div class="overlay-card">
                    <div class="icon" id="instruction-icon">üìç</div>
                    <h2 id="instruction-title">Virtual Pegboard Test</h2>
                    <div class="clinical-ref" id="clinical-ref">Clinical Reference: 9-Hole Peg Test</div>
                    <p id="instruction-text">Pick up pegs and place them into holes as quickly as possible.</p>
                    <div class="btn-group"><button class="demo-btn" id="btn-watch-demo">üëÅ Watch Demo First</button><button class="start-btn" id="btn-begin">‚ñ∂ Start Assessment</button></div>
                </div></div>
                <div class="overlay" id="results-overlay"><div class="overlay-card">
                    <div class="icon">‚úÖ</div><h2>Assessment Complete!</h2>
                    <div class="assessment-name" id="result-name">Virtual Pegboard</div>
                    <div class="results-grid" id="results-grid"></div>
                    <div class="clinical-interpretation"><h4>Clinical Interpretation</h4><p id="interpretation-text">Analysis loading...</p></div>
                    <div class="results-actions"><button class="control-btn secondary" id="btn-retry">‚Ü∫ Retry</button><button class="control-btn secondary" id="btn-export">üìä Export</button><button class="control-btn primary" id="btn-next">Next ‚Üí</button></div>
                </div></div>
            </div>
        </main>
    </div>
    <div class="connection-modal" id="connection-modal"><div class="modal-content">
        <h3>üéÆ Connect etee Controllers</h3><p class="subtitle">Enter the WebSocket server address</p>
        <div id="connection-msg"></div>
        <div class="input-group"><label>Server Address</label><input type="text" id="server-address" value="ws://localhost:8765"></div>
        <div class="modal-actions"><button class="control-btn secondary" id="btn-cancel-connect">Cancel</button><button class="control-btn primary" id="btn-try-connect">Connect</button></div>
    </div></div>
    
    <script>
/* ============================================================================
   JAVASCRIPT SECTION
   ============================================================================ */

/* ============================================================================
   SECTION 1: STATE & CONFIGURATION (js/state.js)
   ============================================================================ */

const AppState = {
    connected: false,
    demoMode: true,
    currentAssessment: 'pegboard',
    isRunning: false,
    isDemo: false,
    startTime: null,
    mousePos: { x: 0, y: 0 },
    leftGrip: false,
    rightGrip: false,
    controllerData: {
        left: { gestures: { grip: { pull: 0, clicked: false } }, trackpad: { x: 127, y: 127 } },
        right: { gestures: { grip: { pull: 0, clicked: false } }, trackpad: { x: 127, y: 127 } }
    }
};

const Assessments = {
    // Motor Dexterity
    pegboard: { name: 'Virtual Pegboard', tag: 'Motor Dexterity', icon: 'üìç', clinicalRef: '9-Hole Peg Test', instructions: 'Pick up pegs and place them into holes as quickly as possible.', metrics: { m1: 'Pegs Placed', m2: 'Accuracy', m3: 'Avg Time' }, scoreLabel: 'Pegs' },
    fingertap: { name: 'Finger Tapping', tag: 'Motor Speed', icon: 'üëÜ', clinicalRef: 'UPDRS Item 3.4', instructions: 'Tap repeatedly as fast as possible. We measure speed and amplitude decrement.', metrics: { m1: 'Tap Count', m2: 'Amplitude', m3: 'Decrement' }, scoreLabel: 'Taps' },
    boxblock: { name: 'Box & Blocks', tag: 'Gross Dexterity', icon: 'üì¶', clinicalRef: 'Box and Block Test', instructions: 'Transfer blocks from one compartment to another quickly.', metrics: { m1: 'Transferred', m2: 'Grip Time', m3: 'Rate/min' }, scoreLabel: 'Blocks' },
    purdue: { name: 'Purdue Pegboard', tag: 'Bimanual Coord', icon: 'üîß', clinicalRef: 'Purdue Pegboard Test', instructions: 'Use both hands simultaneously to place pegs. Tests bimanual coordination.', metrics: { m1: 'Pegs Placed', m2: 'Symmetry', m3: 'Time' }, scoreLabel: 'Pairs' },
    gripforce: { name: 'Grip Force', tag: 'Force Control', icon: '‚úä', clinicalRef: 'Grip Force Modulation', instructions: 'Squeeze to match the target force level shown. Hold steady when matched.', metrics: { m1: 'Accuracy', m2: 'Variability', m3: 'Avg Error' }, scoreLabel: 'Score' },
    fingerseq: { name: 'Finger Sequence', tag: 'Motor Planning', icon: 'üñêÔ∏è', clinicalRef: 'Luria Finger Sequencing', instructions: 'Tap your fingers in the sequence shown. Speed and accuracy are measured.', metrics: { m1: 'Correct', m2: 'Errors', m3: 'Avg Time' }, scoreLabel: 'Sequences' },
    
    // Cognitive Function
    trailmaking: { name: 'Trail Making', tag: 'Executive Function', icon: 'üîó', clinicalRef: 'Trail Making Test A', instructions: 'Connect targets in numerical sequence quickly.', metrics: { m1: 'Progress', m2: 'Errors', m3: 'Time' }, scoreLabel: 'Connected' },
    reactiontime: { name: 'Reaction Time', tag: 'Processing Speed', icon: '‚ö°', clinicalRef: 'Simple Reaction Time', instructions: 'Respond quickly when you see the target.', metrics: { m1: 'Last RT', m2: 'Avg RT', m3: 'Best RT' }, scoreLabel: 'Trials' },
    gonogo: { name: 'Go/No-Go', tag: 'Inhibition', icon: 'üö¶', clinicalRef: 'Go/No-Go Task', instructions: 'Click for GREEN targets, do NOT click for RED. Tests impulse control.', metrics: { m1: 'Hits', m2: 'False Alarms', m3: 'Avg RT' }, scoreLabel: 'Score' },
    nback: { name: 'N-Back', tag: 'Working Memory', icon: 'üß†', clinicalRef: 'N-Back Task', instructions: 'Click if the current shape matches the one from N steps back.', metrics: { m1: 'Hits', m2: 'False Alarms', m3: 'd-Prime' }, scoreLabel: 'Correct' },
    symboldigit: { name: 'Symbol Digit', tag: 'Processing Speed', icon: 'üî¢', clinicalRef: 'Symbol Digit Modalities', instructions: 'Match symbols to digits using the key shown. Work as fast as possible.', metrics: { m1: 'Correct', m2: 'Errors', m3: 'Rate/min' }, scoreLabel: 'Score' },
    stroop: { name: 'Stroop Test', tag: 'Selective Attention', icon: 'üé®', clinicalRef: 'Color-Word Interference', instructions: 'Identify the INK COLOR, not the word.', metrics: { m1: 'Correct', m2: 'Accuracy', m3: 'Avg RT' }, scoreLabel: 'Score' },
    
    // Movement Analysis
    tremor: { name: 'Tremor Analysis', tag: 'Movement Disorder', icon: '„Ä∞Ô∏è', clinicalRef: 'Postural Tremor', instructions: 'Hold your hand steady for analysis.', metrics: { m1: 'Frequency', m2: 'Amplitude', m3: 'Stability' }, scoreLabel: 'Stability' },
    spiral: { name: 'Spiral Drawing', tag: 'Bradykinesia', icon: 'üåÄ', clinicalRef: 'Archimedes Spiral', instructions: 'Trace the spiral from center outward. Speed and smoothness are analyzed.', metrics: { m1: 'Smoothness', m2: 'Speed Decay', m3: 'Accuracy' }, scoreLabel: 'Score' },
    pronation: { name: 'Pronation/Supination', tag: 'Dysdiadochokinesia', icon: 'üîÑ', clinicalRef: 'UPDRS Item 3.6', instructions: 'Alternate gripping left and right as fast as possible.', metrics: { m1: 'Cycles', m2: 'Regularity', m3: 'Rate/sec' }, scoreLabel: 'Cycles' },
    posturalsway: { name: 'Postural Sway', tag: 'Balance', icon: '‚öñÔ∏è', clinicalRef: 'Postural Stability', instructions: 'Hold controllers steady. We analyze drift to assess balance control.', metrics: { m1: 'Sway Area', m2: 'Velocity', m3: 'Stability' }, scoreLabel: 'Stability' },
    coordination: { name: 'Coordination', tag: 'Motor Control', icon: 'üéÆ', clinicalRef: 'Bimanual Coordination', instructions: 'Follow moving targets with your hands.', metrics: { m1: 'Sync Score', m2: 'Phase Error', m3: 'Consistency' }, scoreLabel: 'Sync %' },
    
    // Gamified Assessment
    rhythmslash: { name: 'Rhythm Slasher', tag: 'Multi-Domain', icon: '‚öîÔ∏è', clinicalRef: 'Gamified Assessment', instructions: 'Slash the approaching blocks with the correct saber! Blue blocks with left, purple with right. Move fast!', metrics: { m1: 'Accuracy', m2: 'Combo', m3: 'Avg RT' }, scoreLabel: 'Score' },
    colorsort: { name: 'Color Sort', tag: 'Cognitive', icon: 'üßä', clinicalRef: 'Working Memory + Attention', instructions: 'Catch falling blocks and sort by color! If a color REPEATS, place it in the NEUTRAL bin instead. Tests memory, attention, and cognitive flexibility.', metrics: { m1: 'Correct', m2: 'Errors', m3: 'Avg RT' }, scoreLabel: 'Score' },
    memorymatch: { name: 'Memory Match', tag: 'Visual Memory', icon: 'üÉè', clinicalRef: 'Visual Recognition Memory', instructions: 'Flip cards to find matching pairs! Remember card positions to minimize attempts. Tests visual memory and pattern recognition.', metrics: { m1: 'Attempts', m2: 'Matches', m3: 'Avg Time' }, scoreLabel: 'Pairs' },
    towerstack: { name: 'Tower Stack', tag: 'Motor Planning', icon: 'üèóÔ∏è', clinicalRef: 'Visuomotor Control', instructions: 'Stack blocks as high as possible! Time your drop carefully - blocks swing faster as you go. Tests precision and timing.', metrics: { m1: 'Height', m2: 'Accuracy', m3: 'Falls' }, scoreLabel: 'Blocks' },
    patternrunner: { name: 'Pattern Runner', tag: 'Procedural Memory', icon: 'üî¢', clinicalRef: 'Sequential Memory', instructions: 'Watch the pattern light up, then repeat it! Sequences get longer each round. Tests procedural and sequential memory.', metrics: { m1: 'Sequence', m2: 'Errors', m3: 'Avg RT' }, scoreLabel: 'Score' },
    whackamole: { name: 'Whack-a-Mole', tag: 'Attention', icon: 'üî®', clinicalRef: 'Sustained Attention + RT', instructions: 'Whack the moles as fast as you can! They appear randomly and disappear quickly. Tests reaction time and vigilance.', metrics: { m1: 'Hits', m2: 'Misses', m3: 'Avg RT' }, scoreLabel: 'Score' },
    balanceboard: { name: 'Balance Board', tag: 'Postural Control', icon: '‚öñÔ∏è', clinicalRef: 'Dynamic Balance', instructions: 'Tilt the board to guide the ball to each target! Stay in the target zone to score. Tests balance and fine motor control.', metrics: { m1: 'Targets', m2: 'Falls', m3: 'Stability' }, scoreLabel: 'Score' }
};


/* ============================================================================
   SECTION 2: CORE CLASSES (js/core.js)
   ============================================================================ */

/* ----------------------------------------------------------------------------
   EteeConnection - WebSocket connection to etee controllers
   ---------------------------------------------------------------------------- */
class EteeConnection {
    constructor() {
        this.ws = null;
    }
    
    connect(url) {
        return new Promise((resolve, reject) => {
            try {
                this.ws = new WebSocket(url);
                
                this.ws.onopen = () => {
                    AppState.connected = true;
                    AppState.demoMode = false;
                    this.updateUI(true);
                    resolve(true);
                };
                
                this.ws.onmessage = (e) => {
                    const d = JSON.parse(e.data);
                    if (d.type === 'controller_state') {
                        ['left', 'right'].forEach(h => {
                            if (d[h]) {
                                AppState.controllerData[h] = {
                                    gestures: d[h].gestures || { grip: { pull: 0, clicked: false } },
                                    trackpad: d[h].trackpad || { x: 127, y: 127 }
                                };
                            }
                        });
                    }
                };
                
                this.ws.onerror = () => reject(new Error('Connection failed'));
                
                this.ws.onclose = () => {
                    AppState.connected = false;
                    AppState.demoMode = true;
                    this.updateUI(false);
                };
                
                setTimeout(() => {
                    if (this.ws.readyState !== WebSocket.OPEN) reject(new Error('Timeout'));
                }, 5000);
            } catch (e) {
                reject(e);
            }
        });
    }
    
    updateUI(connected) {
        document.getElementById('connection-dot').classList.toggle('connected', connected);
        document.getElementById('connection-status').textContent = connected ? 'Connected' : 'Demo Mode';
        document.getElementById('demo-notice').style.display = connected ? 'none' : 'block';
        
        const badge = document.getElementById('mode-badge');
        badge.textContent = connected ? 'Live Mode' : 'Demo Mode';
        badge.style.background = connected ? 'rgba(0,255,136,0.15)' : 'rgba(255,215,0,0.15)';
        badge.style.borderColor = connected ? '#00ff88' : '#ffd700';
        badge.style.color = connected ? '#00ff88' : '#ffd700';
        
        const btn = document.getElementById('btn-connect');
        btn.textContent = connected ? '‚úì Connected' : 'üéÆ Connect etee Controllers';
        btn.classList.toggle('connected', connected);
    }
}

/* ----------------------------------------------------------------------------
   InputHandler - Mouse/Keyboard input for Demo Mode
   ---------------------------------------------------------------------------- */
class InputHandler {
    constructor() {
        const container = document.getElementById('game-container');
        const cursor = document.getElementById('game-cursor');
        
        container.addEventListener('mousemove', (e) => {
            const r = container.getBoundingClientRect();
            AppState.mousePos.x = e.clientX - r.left;
            AppState.mousePos.y = e.clientY - r.top;
            cursor.style.left = AppState.mousePos.x + 'px';
            cursor.style.top = AppState.mousePos.y + 'px';
            
            if (AppState.demoMode) {
                AppState.controllerData.right.trackpad = {
                    x: Math.floor((AppState.mousePos.x / r.width) * 255),
                    y: Math.floor((AppState.mousePos.y / r.height) * 255)
                };
                AppState.controllerData.left.trackpad = AppState.controllerData.right.trackpad;
            }
        });
        
        container.addEventListener('mousedown', () => {
            AppState.rightGrip = true;
            this.updateGrip();
            cursor.classList.add('gripping');
        });
        
        container.addEventListener('mouseup', () => {
            AppState.rightGrip = false;
            this.updateGrip();
            cursor.classList.remove('gripping');
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                AppState.leftGrip = AppState.rightGrip = true;
                this.updateGrip();
            }
            if (e.key === 'Escape' && AppState.isRunning) stopAssessment();
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                AppState.leftGrip = AppState.rightGrip = false;
                this.updateGrip();
            }
        });
    }
    
    updateGrip() {
        if (AppState.demoMode) {
            const lv = AppState.leftGrip ? 100 : 0;
            const rv = AppState.rightGrip ? 100 : 0;
            AppState.controllerData.left.gestures.grip = { pull: lv, clicked: lv > 80 };
            AppState.controllerData.right.gestures.grip = { pull: rv, clicked: rv > 80 };
            
            ['left', 'right'].forEach(h => {
                const g = h === 'left' ? AppState.leftGrip : AppState.rightGrip;
                const v = g ? 100 : Math.random() * 15;
                ['thumb', 'index', 'middle', 'ring', 'pinky'].forEach(f => {
                    const el = document.getElementById(h + '-' + f);
                    if (el) el.style.height = v + '%';
                });
                const s = document.getElementById(h + '-grip-state');
                if (s) {
                    s.textContent = g ? 'GRIP' : 'OPEN';
                    s.style.color = g ? '#00ff88' : '#ffd700';
                }
            });
        }
    }
}


/* ----------------------------------------------------------------------------
   GameEngine - Three.js rendering engine
   ---------------------------------------------------------------------------- */
    class GameEngine {
        constructor() { this.scene = null; this.camera = null; this.renderer = null; this.clock = new THREE.Clock(); this.currentModule = null; this.raycaster = new THREE.Raycaster(); 
            this.avatarScene = null; this.avatarCamera = null; }
        init() { const c = document.getElementById('game-container'); this.scene = new THREE.Scene(); this.scene.background = new THREE.Color(0x0a0a0f); this.scene.fog = new THREE.Fog(0x0a0a0f, 15, 40);
            this.camera = new THREE.PerspectiveCamera(50, c.clientWidth/c.clientHeight, 0.1, 1000); this.camera.position.set(0,8,12); this.camera.lookAt(0,0,0);
            this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true }); this.renderer.setSize(c.clientWidth, c.clientHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)); this.renderer.shadowMap.enabled = true;
            this.renderer.autoClear = false; // Important for multiple viewports
            this.scene.add(new THREE.AmbientLight(0x404050, 0.6)); const main = new THREE.DirectionalLight(0xffffff, 1); main.position.set(5,15,10); main.castShadow = true; main.shadow.mapSize.width = main.shadow.mapSize.height = 2048; this.scene.add(main);
            const blue = new THREE.PointLight(0x00d4ff, 0.5, 30); blue.position.set(-8,5,-8); this.scene.add(blue); const purple = new THREE.PointLight(0xa855f7, 0.3, 30); purple.position.set(8,5,-8); this.scene.add(purple);
            const grid = new THREE.GridHelper(40, 40, 0x00d4ff, 0x1a1a25); grid.position.y = 0.01; grid.material.opacity = 0.3; grid.material.transparent = true; this.scene.add(grid);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({ color: 0x0f0f15, roughness: 0.9 })); floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; this.scene.add(floor);
            // Create separate avatar scene
            this.avatarScene = new THREE.Scene(); this.avatarScene.background = new THREE.Color(0x12121a);
            this.avatarCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100); this.avatarCamera.position.set(0, 1.5, 3.5); this.avatarCamera.lookAt(0, 1.2, 0);
            this.avatarScene.add(new THREE.AmbientLight(0x404050, 0.8));
            const avatarLight = new THREE.DirectionalLight(0xffffff, 1); avatarLight.position.set(2, 4, 3); this.avatarScene.add(avatarLight);
            const avatarBlue = new THREE.PointLight(0x00d4ff, 0.5, 10); avatarBlue.position.set(-2, 2, 2); this.avatarScene.add(avatarBlue);
            const avatarPurple = new THREE.PointLight(0xa855f7, 0.3, 10); avatarPurple.position.set(2, 2, 2); this.avatarScene.add(avatarPurple);
            // Avatar floor
            const avatarFloor = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), new THREE.MeshStandardMaterial({ color: 0x1a1a25 })); avatarFloor.rotation.x = -Math.PI/2; avatarFloor.position.y = 0.01; this.avatarScene.add(avatarFloor);
            window.addEventListener('resize', () => { this.camera.aspect = c.clientWidth/c.clientHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(c.clientWidth, c.clientHeight); }); }
        loadAssessment(id) { if (this.currentModule) this.currentModule.cleanup(); this.camera.position.set(0,8,12); this.camera.lookAt(0,0,0);
            const M = { pegboard: PegboardModule, fingertap: FingerTapModule, boxblock: BoxBlockModule, purdue: PurdueModule, gripforce: GripForceModule, fingerseq: FingerSeqModule, trailmaking: TrailMakingModule, reactiontime: ReactionTimeModule, gonogo: GoNoGoModule, nback: NBackModule, symboldigit: SymbolDigitModule, stroop: StroopModule, tremor: TremorModule, spiral: SpiralModule, pronation: PronationModule, posturalsway: PosturalSwayModule, coordination: CoordinationModule, rhythmslash: RhythmSlasherModule, colorsort: ColorSortModule, memorymatch: MemoryMatchModule, towerstack: TowerStackModule, patternrunner: PatternRunnerModule, whackamole: WhackAMoleModule, balanceboard: BalanceBoardModule };
            this.currentModule = new (M[id]||PegboardModule)(this); this.currentModule.init(); }
        update() { const dt = this.clock.getDelta(); if (this.currentModule) this.currentModule.update(dt, AppState.controllerData); if(this.avatar) this.avatar.update(AppState.controllerData); }
        render() { 
            this.update(); 
            const c = document.getElementById('game-container');
            // Clear everything
            this.renderer.clear();
            // Render main scene (full viewport)
            this.renderer.setViewport(0, 0, c.clientWidth, c.clientHeight);
            this.renderer.setScissor(0, 0, c.clientWidth, c.clientHeight);
            this.renderer.setScissorTest(false);
            this.renderer.render(this.scene, this.camera);
            // Render avatar viewport (top-right corner) if visible
            if (this.avatar && this.avatar.visible) {
                const avSize = Math.min(200, c.clientWidth * 0.25);
                const avX = c.clientWidth - avSize - 15;
                const avY = c.clientHeight - avSize - 60; // Below the HUD
                this.renderer.setViewport(avX, avY, avSize, avSize);
                this.renderer.setScissor(avX, avY, avSize, avSize);
                this.renderer.setScissorTest(true);
                this.renderer.render(this.avatarScene, this.avatarCamera);
                this.renderer.setScissorTest(false);
            }
        }
        getWorldPosition(sx, sy, y=0) { const c = document.getElementById('game-container'); this.raycaster.setFromCamera({ x: (sx/c.clientWidth)*2-1, y: -(sy/c.clientHeight)*2+1 }, this.camera);
            const t = new THREE.Vector3(); this.raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0,1,0), -y), t); return t; }
        createAvatar() { this.avatar = new DigitalTwin(this.avatarScene); this.avatar.group.position.set(0, 0, 0); }
        setAvatarVisible(v) { if(this.avatar) this.avatar.setVisible(v); }
    }

    // ============================================================================
    // DIGITAL TWIN - Stick Figure Avatar
    // ============================================================================
    class DigitalTwin {
        constructor(scene) {
            this.scene = scene;
            this.group = new THREE.Group();
            this.group.position.set(7, 0, 0);
            this.visible = true;
            this.joints = {};
            this.limbs = {};
            this.createAvatar();
            this.scene.add(this.group);
        }
        
        createAvatar() {
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 0.6 });
            const boneMat = new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x006688, emissiveIntensity: 0.4 });
            const jointGeo = new THREE.SphereGeometry(0.06, 12, 12);
            
            // Joint positions for T-pose reference (will be updated dynamically for arms)
            const jointDefs = {
                head: [0, 2.1, 0], neck: [0, 1.9, 0], 
                shoulder_l: [-0.3, 1.8, 0], shoulder_r: [0.3, 1.8, 0],
                elbow_l: [-0.55, 1.45, 0.15], elbow_r: [0.55, 1.45, 0.15],
                wrist_l: [-0.55, 1.1, 0.3], wrist_r: [0.55, 1.1, 0.3],
                spine: [0, 1.5, 0], pelvis: [0, 1.1, 0],
                hip_l: [-0.15, 1.05, 0], hip_r: [0.15, 1.05, 0],
                knee_l: [-0.15, 0.55, 0], knee_r: [0.15, 0.55, 0],
                ankle_l: [-0.15, 0.08, 0], ankle_r: [0.15, 0.08, 0]
            };
            
            // Create joints
            for (const [name, pos] of Object.entries(jointDefs)) {
                const joint = new THREE.Mesh(jointGeo, jointMat.clone());
                joint.position.set(pos[0], pos[1], pos[2]);
                this.joints[name] = joint;
                this.group.add(joint);
            }
            
            // Head (larger sphere)
            const headGeo = new THREE.SphereGeometry(0.14, 16, 16);
            const head = new THREE.Mesh(headGeo, jointMat.clone());
            head.position.set(0, 2.1, 0);
            this.joints.head_sphere = head;
            this.group.add(head);
            
            // Define limbs (bone connections)
            const limbDefs = [
                ['neck', 'head', 0.03], ['spine', 'neck', 0.035], ['pelvis', 'spine', 0.04],
                ['neck', 'shoulder_l', 0.025], ['neck', 'shoulder_r', 0.025],
                ['shoulder_l', 'elbow_l', 0.03], ['shoulder_r', 'elbow_r', 0.03],
                ['elbow_l', 'wrist_l', 0.025], ['elbow_r', 'wrist_r', 0.025],
                ['pelvis', 'hip_l', 0.03], ['pelvis', 'hip_r', 0.03],
                ['hip_l', 'knee_l', 0.035], ['hip_r', 'knee_r', 0.035],
                ['knee_l', 'ankle_l', 0.03], ['knee_r', 'ankle_r', 0.03]
            ];
            
            // Create limbs as cylinders
            for (const [from, to, radius] of limbDefs) {
                const limbGeo = new THREE.CylinderGeometry(radius, radius, 1, 8);
                const limb = new THREE.Mesh(limbGeo, boneMat.clone());
                this.limbs[from + '_' + to] = { mesh: limb, from, to };
                this.group.add(limb);
            }
            
            // Controllers (hands)
            const ctrlGeo = new THREE.BoxGeometry(0.1, 0.05, 0.15);
            this.leftCtrl = new THREE.Mesh(ctrlGeo, new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.4 }));
            this.rightCtrl = new THREE.Mesh(ctrlGeo, new THREE.MeshStandardMaterial({ color: 0xa855f7, emissive: 0xa855f7, emissiveIntensity: 0.4 }));
            this.group.add(this.leftCtrl);
            this.group.add(this.rightCtrl);
            
            // Fingers on controllers
            this.leftFingers = []; this.rightFingers = [];
            for (let i = 0; i < 5; i++) {
                const fGeo = new THREE.BoxGeometry(0.015, 0.04, 0.012);
                const fL = new THREE.Mesh(fGeo, new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5 }));
                const fR = new THREE.Mesh(fGeo, new THREE.MeshStandardMaterial({ color: 0xa855f7, emissive: 0xa855f7, emissiveIntensity: 0.5 }));
                fL.position.set(-0.035 + i * 0.018, 0.045, 0);
                fR.position.set(-0.035 + i * 0.018, 0.045, 0);
                this.leftCtrl.add(fL); this.rightCtrl.add(fR);
                this.leftFingers.push(fL); this.rightFingers.push(fR);
            }
            
            this.updateLimbs();
        }
        
        updateLimbs() {
            for (const [key, limb] of Object.entries(this.limbs)) {
                const p1 = this.joints[limb.from].position;
                const p2 = this.joints[limb.to].position;
                const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                const dir = new THREE.Vector3().subVectors(p2, p1);
                const len = dir.length();
                
                limb.mesh.position.copy(mid);
                limb.mesh.scale.y = len;
                
                // Orient cylinder to point from p1 to p2
                const up = new THREE.Vector3(0, 1, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
                limb.mesh.quaternion.copy(quat);
            }
        }
        
        update(controllerData) {
            if (!this.visible) return;
            
            const lt = controllerData.left?.trackpad || { x: 127, y: 127 };
            const rt = controllerData.right?.trackpad || { x: 127, y: 127 };
            const lg = controllerData.left?.gestures?.grip || { pull: 0 };
            const rg = controllerData.right?.gestures?.grip || { pull: 0 };
            
            // Normalize trackpad values (-1 to 1)
            const lx = (lt.x - 127) / 127;
            const ly = (lt.y - 127) / 127;
            const rx = (rt.x - 127) / 127;
            const ry = (rt.y - 127) / 127;
            
            // Arm IK targets based on trackpad
            const shoulderL = this.joints.shoulder_l.position;
            const shoulderR = this.joints.shoulder_r.position;
            
            // Left arm target
            const leftTarget = new THREE.Vector3(
                shoulderL.x - 0.15 + lx * 0.25,
                shoulderL.y - 0.5 - ly * 0.3,
                0.2 + Math.abs(ly) * 0.2
            );
            
            // Right arm target  
            const rightTarget = new THREE.Vector3(
                shoulderR.x + 0.15 + rx * 0.25,
                shoulderR.y - 0.5 - ry * 0.3,
                0.2 + Math.abs(ry) * 0.2
            );
            
            // Solve IK for arms
            this.solveArmIK('l', leftTarget);
            this.solveArmIK('r', rightTarget);
            
            // Update controller positions
            this.leftCtrl.position.copy(this.joints.wrist_l.position);
            this.leftCtrl.position.y -= 0.05;
            this.leftCtrl.rotation.set(ly * 0.4, 0, -lx * 0.3);
            
            this.rightCtrl.position.copy(this.joints.wrist_r.position);
            this.rightCtrl.position.y -= 0.05;
            this.rightCtrl.rotation.set(ry * 0.4, 0, rx * 0.3);
            
            // Finger curl based on grip
            const lGrip = lg.pull || 0;
            const rGrip = rg.pull || 0;
            
            this.leftFingers.forEach((f, i) => {
                f.rotation.x = (lGrip / 100) * Math.PI * 0.5;
                f.position.y = 0.045 - (lGrip / 100) * 0.02;
            });
            this.rightFingers.forEach((f, i) => {
                f.rotation.x = (rGrip / 100) * Math.PI * 0.5;
                f.position.y = 0.045 - (rGrip / 100) * 0.02;
            });
            
            // Controller glow
            this.leftCtrl.material.emissiveIntensity = 0.4 + (lGrip / 100) * 0.6;
            this.rightCtrl.material.emissiveIntensity = 0.4 + (rGrip / 100) * 0.6;
            
            // Subtle body animation
            const t = Date.now() * 0.001;
            this.joints.head.position.x = Math.sin(t * 0.5) * 0.01;
            this.joints.head_sphere.position.copy(this.joints.head.position);
            this.joints.spine.position.x = Math.sin(t * 0.3) * 0.005;
            
            this.updateLimbs();
        }
        
        solveArmIK(side, target) {
            const shoulder = this.joints['shoulder_' + side];
            const elbow = this.joints['elbow_' + side];
            const wrist = this.joints['wrist_' + side];
            
            const upperLen = 0.4;
            const lowerLen = 0.38;
            const maxReach = upperLen + lowerLen - 0.02;
            
            // Vector from shoulder to target
            const toTarget = new THREE.Vector3().subVectors(target, shoulder.position);
            let dist = toTarget.length();
            
            // Clamp distance
            if (dist > maxReach) {
                dist = maxReach;
                toTarget.normalize().multiplyScalar(dist);
            }
            
            // Wrist at target (clamped)
            wrist.position.copy(shoulder.position).add(toTarget);
            
            // Elbow position using law of cosines
            if (dist > 0.01 && dist < maxReach) {
                const a = upperLen, b = lowerLen, c = dist;
                const cosAngle = Math.max(-1, Math.min(1, (a*a + c*c - b*b) / (2*a*c)));
                const angle = Math.acos(cosAngle);
                
                // Direction from shoulder to wrist
                const dir = toTarget.clone().normalize();
                
                // Perpendicular direction for elbow bend (outward and back)
                const perp = new THREE.Vector3(side === 'l' ? -1 : 1, 0, -1).normalize();
                
                // Elbow position
                const elbowDist = upperLen;
                const elbowOffset = perp.multiplyScalar(Math.sin(angle) * elbowDist * 0.5);
                const elbowAlong = dir.clone().multiplyScalar(Math.cos(angle) * elbowDist);
                
                elbow.position.copy(shoulder.position).add(elbowAlong).add(elbowOffset);
            } else {
                // Arm mostly straight
                elbow.position.lerpVectors(shoulder.position, wrist.position, 0.5);
                elbow.position.z += 0.1;
                elbow.position.x += side === 'l' ? -0.05 : 0.05;
            }
        }
        
        setVisible(v) {
            this.visible = v;
            this.group.visible = v;
        }
        
        setPosition(x, y, z) {
            this.group.position.set(x, y, z);
        }
    }



/* ============================================================================
   SECTION 3: ASSESSMENT MODULES (js/modules/*.js)
   
   Each module can be extracted to its own file:
   - js/modules/base-module.js
   - js/modules/motor/pegboard.js
   - js/modules/motor/fingertap.js
   - js/modules/cognitive/trailmaking.js
   - js/modules/gamified/rhythmslash.js
   - etc.
   ============================================================================ */

/* ----------------------------------------------------------------------------
   BaseModule - Parent class for all assessment modules
   File: js/modules/base-module.js
   ---------------------------------------------------------------------------- */
    class BaseModule {
        constructor(e) { this.engine = e; this.scene = e.scene; this.objects = []; this.isRunning = false; this.isDemo = false; this.demoTime = 0; }
        init() {} start(d=false) { this.isRunning = true; this.isDemo = d; this.demoTime = 0; AppState.startTime = Date.now(); }
        stop() { this.isRunning = false; this.isDemo = false; return this.getResults(); } update(dt, cd) {} getResults() { return {}; }
        cleanup() { this.objects.forEach(o => { this.scene.remove(o); if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); }); this.objects = []; }
        addObject(o) { this.scene.add(o); this.objects.push(o); return o; }
        createGlowMaterial(c, i=0.5) { return new THREE.MeshStandardMaterial({ color:c, emissive:c, emissiveIntensity:i, roughness:0.3, metalness:0.6 }); }
        createTextSprite(t, s=0.5, c='#ffffff') { const cv = document.createElement('canvas'), ctx = cv.getContext('2d'); 
            ctx.font = 'bold 48px Outfit'; const textWidth = ctx.measureText(t).width;
            cv.width = Math.max(512, textWidth + 64); cv.height = 128;
            ctx.fillStyle = c; ctx.font = 'bold 48px Outfit'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t, cv.width/2, 64);
            const aspect = cv.width / cv.height; const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cv), transparent: true })); sp.scale.set(s*aspect*2, s, 1); return sp; }
        updateTimer() { if (!AppState.startTime) return; const e = (Date.now() - AppState.startTime)/1000;
            document.getElementById('timer').textContent = Math.floor(e/60).toString().padStart(2,'0')+':'+Math.floor(e%60).toString().padStart(2,'0'); }
    }

/* --- MOTOR: PegboardModule (js/modules/motor/pegboard.js) --- */
    class PegboardModule extends BaseModule {
        constructor(e) { super(e); this.pegs = []; this.holes = []; this.heldPeg = null; this.completedCount = 0; this.pegTimes = []; this.lastGripState = false; }
        init() { this.engine.camera.position.set(0,10,8); this.engine.camera.lookAt(0,0,0);
            const board = new THREE.Mesh(new THREE.BoxGeometry(5,0.4,4), new THREE.MeshStandardMaterial({color:0x2a2a35})); board.position.set(1.5,0.2,0); board.receiveShadow = true; this.addObject(board);
            for(let r=0; r<3; r++) for(let c=0; c<3; c++) { const h = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.5,24), new THREE.MeshStandardMaterial({color:0x0a0a0f}));
                h.position.set(0.5+c*0.8, 0.2, -0.8+r*0.8); h.userData = {index:r*3+c, filled:false}; this.holes.push(h); this.addObject(h);
                const rim = new THREE.Mesh(new THREE.TorusGeometry(0.2,0.03,8,32), this.createGlowMaterial(0x00d4ff, 0.3)); rim.position.set(0.5+c*0.8, 0.42, -0.8+r*0.8); rim.rotation.x = -Math.PI/2; this.addObject(rim); }
            const cont = new THREE.Mesh(new THREE.BoxGeometry(2,0.3,2), new THREE.MeshStandardMaterial({color:0x1a1a25})); cont.position.set(-3,0.15,0); this.addObject(cont);
            const lbl = this.createTextSprite('PEGS', 0.4, '#00d4ff'); lbl.position.set(-3,0.8,0); this.addObject(lbl);
            const colors = [0x00d4ff, 0xa855f7, 0xff006e, 0x00ff88, 0xffd700, 0xff6b35, 0x00d4ff, 0xa855f7, 0xff006e];
            for(let i=0; i<9; i++) { const p = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.6,16), this.createGlowMaterial(colors[i], 0.4));
                const a = (i/9)*Math.PI*2; p.position.set(-3+Math.cos(a)*0.6, 0.5, Math.sin(a)*0.6);
                p.userData = {index:i, placed:false, held:false, originalPos:p.position.clone(), pickupTime:null}; p.castShadow = true; this.pegs.push(p); this.addObject(p); } }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.5), grip = cd.right.gestures.grip, isG = grip?.clicked||false;
            if(isG && !this.lastGripState && !this.heldPeg) { for(const p of this.pegs) { if(!p.userData.placed && !p.userData.held) {
                if(Math.sqrt(Math.pow(wp.x-p.position.x,2)+Math.pow(wp.z-p.position.z,2))<0.5) { this.heldPeg = p; p.userData.held = true; p.userData.pickupTime = Date.now(); p.scale.set(1.3,1.3,1.3); p.material.emissiveIntensity = 0.8; break; } } } }
            if(!isG && this.lastGripState && this.heldPeg) { let placed = false;
                for(const h of this.holes) { if(!h.userData.filled && Math.sqrt(Math.pow(wp.x-h.position.x,2)+Math.pow(wp.z-h.position.z,2))<0.4) {
                    this.heldPeg.position.copy(h.position); this.heldPeg.position.y = 0.55; this.heldPeg.userData.placed = true; h.userData.filled = true; this.completedCount++; placed = true;
                    this.pegTimes.push(Date.now() - this.heldPeg.userData.pickupTime); document.getElementById('metric-1').textContent = this.completedCount; document.getElementById('score').textContent = this.completedCount;
                    if(this.pegTimes.length>0) document.getElementById('metric-3').textContent = (this.pegTimes.reduce((a,b)=>a+b,0)/this.pegTimes.length/1000).toFixed(2)+'s'; break; } }
                if(!placed) this.heldPeg.position.copy(this.heldPeg.userData.originalPos); this.heldPeg.scale.set(1,1,1); this.heldPeg.material.emissiveIntensity = 0.4; this.heldPeg.userData.held = false; this.heldPeg = null; }
            if(this.heldPeg && wp) { this.heldPeg.position.x = wp.x; this.heldPeg.position.z = wp.z; this.heldPeg.position.y = 1.2; }
            this.lastGripState = isG; this.pegs.forEach((p,i) => { if(!p.userData.held && !p.userData.placed) { p.position.y = 0.5+Math.sin(Date.now()*0.003+i)*0.03; p.rotation.y += dt*0.5; } });
            this.updateTimer(); if(this.completedCount >= 9) showResults('pegboard', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; const pi = Math.floor(this.demoTime/1.5); if(pi<9) { const p = this.pegs[pi], h = this.holes[pi];
            if(p && h && !p.userData.placed) { const pr = (this.demoTime%1.5)/1.5;
                if(pr<0.5) p.position.y = 0.5+pr*2; else if(pr<0.9) { const t=(pr-0.5)/0.4; p.position.x = p.userData.originalPos.x+(h.position.x-p.userData.originalPos.x)*t; p.position.z = p.userData.originalPos.z+(h.position.z-p.userData.originalPos.z)*t; p.position.y = 1.5; }
                else { p.position.copy(h.position); p.position.y = 0.55; p.userData.placed = true; h.userData.filled = true; this.completedCount++; document.getElementById('metric-1').textContent = this.completedCount; document.getElementById('score').textContent = this.completedCount; } } }
            this.updateTimer(); if(this.demoTime>15) stopAssessment(); }
        getResults() { const tt = AppState.startTime?(Date.now()-AppState.startTime)/1000:0, at = this.pegTimes.length>0?this.pegTimes.reduce((a,b)=>a+b,0)/this.pegTimes.length/1000:0;
            return { pegsPlaced: this.completedCount, totalTime: tt.toFixed(2), avgPegTime: at.toFixed(2) }; }
    }

/* --- MOTOR: FingerTapModule (js/modules/motor/fingertap.js) --- */
    class FingerTapModule extends BaseModule {
        constructor(e) { super(e); this.tapCount = 0; this.amplitudes = []; this.lastState = false; this.targetTaps = 20; this.indicator = null; this.tapMarkers = []; }
        init() { this.engine.camera.position.set(0,6,10); this.engine.camera.lookAt(0,2,0);
            this.indicator = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), this.createGlowMaterial(0x00d4ff, 0.5)); this.indicator.position.set(0,3,0); this.addObject(this.indicator);
            const lbl = this.createTextSprite('TAP!', 1, '#00d4ff'); lbl.position.set(0,5.5,0); this.addObject(lbl);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(2.5,0.08,8,64), new THREE.MeshStandardMaterial({color:0x2a2a35})); ring.position.set(0,3,0); ring.rotation.x = Math.PI/2; this.addObject(ring);
            for(let i=0; i<this.targetTaps; i++) { const a = (i/this.targetTaps)*Math.PI*2-Math.PI/2, m = new THREE.Mesh(new THREE.SphereGeometry(0.12,16,16), new THREE.MeshStandardMaterial({color:0x2a2a35}));
                m.position.set(Math.cos(a)*2.5, 3, Math.sin(a)*2.5); this.tapMarkers.push(m); this.addObject(m); } }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const grip = cd.right.gestures.grip, isP = grip?.clicked||false; if(isP && !this.lastState) this.onTap(grip?.pull||100); this.lastState = isP;
            const sc = 1+(grip?.pull||0)/126*0.5; this.indicator.scale.set(sc,sc,sc); this.indicator.material.emissiveIntensity = 0.3+Math.sin(Date.now()*0.005)*0.2;
            this.updateTimer(); if(this.tapCount >= this.targetTaps) showResults('fingertap', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; const et = Math.floor(this.demoTime/0.4); if(et>this.tapCount && this.tapCount<this.targetTaps) this.onTap(Math.max(60, 100-this.tapCount*2+Math.random()*10));
            const ph = (this.demoTime%0.4)/0.4; this.indicator.scale.setScalar(1+Math.sin(ph*Math.PI)*0.5); this.updateTimer(); if(this.tapCount>=this.targetTaps) setTimeout(()=>stopAssessment(),1000); }
        onTap(amp) { this.tapCount++; this.amplitudes.push(amp); if(this.tapMarkers[this.tapCount-1]) { const m = this.tapMarkers[this.tapCount-1]; m.material.color.setHex(0x00ff88); m.material.emissive = new THREE.Color(0x00ff88); m.material.emissiveIntensity = 0.5; }
            this.indicator.material.emissiveIntensity = 1; setTimeout(()=>{this.indicator.material.emissiveIntensity=0.5;},100);
            document.getElementById('metric-1').textContent = this.tapCount; document.getElementById('score').textContent = this.tapCount;
            document.getElementById('metric-2').textContent = (this.amplitudes.reduce((a,b)=>a+b,0)/this.amplitudes.length).toFixed(0);
            if(this.amplitudes.length>=5) { const f5 = this.amplitudes.slice(0,5).reduce((a,b)=>a+b,0)/5, l5 = this.amplitudes.slice(-5).reduce((a,b)=>a+b,0)/5; document.getElementById('metric-3').textContent = ((f5-l5)/f5*100).toFixed(1)+'%'; } }
        getResults() { const aa = this.amplitudes.length>0?this.amplitudes.reduce((a,b)=>a+b,0)/this.amplitudes.length:0; let dec = 0;
            if(this.amplitudes.length>=10) { const f5 = this.amplitudes.slice(0,5).reduce((a,b)=>a+b,0)/5, l5 = this.amplitudes.slice(-5).reduce((a,b)=>a+b,0)/5; dec = (f5-l5)/f5*100; }
            return { tapCount: this.tapCount, avgAmplitude: aa.toFixed(1), decrement: dec.toFixed(1)+'%' }; }
    }

/* --- MOTOR: BoxBlockModule (js/modules/motor/boxblock.js) --- */
    class BoxBlockModule extends BaseModule {
        constructor(e) { super(e); this.blocks = []; this.heldBlock = null; this.transferred = 0; this.lastGripState = false; this.transferTimes = []; }
        init() { this.engine.camera.position.set(0,10,10); this.engine.camera.lookAt(0,0,0);
            const bm = new THREE.MeshStandardMaterial({color:0x1a1a25}); const lb = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), bm); lb.position.set(-3,0.25,0); this.addObject(lb);
            const rb = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), bm.clone()); rb.position.set(3,0.25,0); this.addObject(rb);
            const dv = new THREE.Mesh(new THREE.BoxGeometry(0.2,1.5,4), this.createGlowMaterial(0x00d4ff, 0.3)); dv.position.set(0,0.75,0); this.addObject(dv);
            const ll = this.createTextSprite('SOURCE', 0.4, '#00d4ff'); ll.position.set(-3,1.5,0); this.addObject(ll);
            const rl = this.createTextSprite('TARGET', 0.4, '#00ff88'); rl.position.set(3,1.5,0); this.addObject(rl);
            const colors = [0x00d4ff, 0xa855f7, 0xff006e, 0x00ff88, 0xffd700];
            const gridPositions = [];
            for(let row=0; row<4; row++) for(let col=0; col<4; col++) if(gridPositions.length<15) gridPositions.push({x: -4.1 + col*0.7, z: -1.05 + row*0.7});
            for(let i=0; i<15; i++) { const b = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), this.createGlowMaterial(colors[i%5], 0.3));
                const pos = gridPositions[i] || {x: -3, z: 0}; b.position.set(pos.x + (Math.random()-0.5)*0.15, 0.75, pos.z + (Math.random()-0.5)*0.15);
                b.rotation.y = Math.random()*Math.PI; b.userData = {index:i, transferred:false, held:false, pickupTime:null}; b.castShadow = true; this.blocks.push(b); this.addObject(b); } }
        findValidPosition(centerX, range, exclude) { let x, z, valid, attempts = 0; do { x = centerX+(Math.random()-0.5)*range; z = (Math.random()-0.5)*range; valid = true;
            for(const ob of this.blocks) { if(ob !== exclude && !ob.userData.held && Math.abs(ob.position.x - centerX) < 2.5 && Math.sqrt(Math.pow(x-ob.position.x,2)+Math.pow(z-ob.position.z,2))<0.55) { valid = false; break; } }
            attempts++; } while(!valid && attempts<100); return {x, z}; }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.75), grip = cd.right.gestures.grip, isG = grip?.clicked||false;
            if(isG && !this.lastGripState && !this.heldBlock) { for(const b of this.blocks) { if(!b.userData.transferred && !b.userData.held && b.position.x<0) {
                if(Math.sqrt(Math.pow(wp.x-b.position.x,2)+Math.pow(wp.z-b.position.z,2))<0.7) { this.heldBlock = b; b.userData.held = true; b.userData.pickupTime = Date.now(); b.scale.set(1.2,1.2,1.2); b.material.emissiveIntensity = 0.8; break; } } } }
            if(!isG && this.lastGripState && this.heldBlock) { if(wp.x>1) { const pos = this.findValidPosition(3, 2.5, this.heldBlock); this.heldBlock.position.set(pos.x, 0.75, pos.z); this.heldBlock.userData.transferred = true; this.transferred++; this.transferTimes.push(Date.now()-this.heldBlock.userData.pickupTime); }
                else { const pos = this.findValidPosition(-3, 2.5, this.heldBlock); this.heldBlock.position.set(pos.x, 0.75, pos.z); }
                this.heldBlock.scale.set(1,1,1); this.heldBlock.material.emissiveIntensity = 0.3; this.heldBlock.userData.held = false; this.heldBlock = null; }
            if(this.heldBlock && wp) { this.heldBlock.position.x = wp.x; this.heldBlock.position.z = wp.z; this.heldBlock.position.y = 1.5; }
            this.lastGripState = isG; this.blocks.forEach(b => { if(!b.userData.held && !b.userData.transferred) b.rotation.y += dt*0.2; }); this.updateMetrics(); this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const bi = Math.floor(this.demoTime/1.2); if(bi<this.blocks.length) { const b = this.blocks[bi];
            if(b && !b.userData.transferred) { const pr = (this.demoTime%1.2)/1.2; if(pr<0.3) b.position.y = 0.75+pr*3; else if(pr<0.7) { b.position.x += 0.1; b.position.y = 1.8; }
                else if(pr<0.9) b.position.y = 1.8-(pr-0.7)*5; else { const pos = this.findValidPosition(3, 2.5, b); b.position.set(pos.x, 0.75, pos.z); b.userData.transferred = true; this.transferred++; this.updateMetrics(); } } }
            this.updateTimer(); if(this.demoTime>20) stopAssessment(); }
        updateMetrics() { document.getElementById('metric-1').textContent = this.transferred; document.getElementById('score').textContent = this.transferred;
            if(this.transferTimes.length>0) document.getElementById('metric-2').textContent = (this.transferTimes.reduce((a,b)=>a+b,0)/this.transferTimes.length/1000).toFixed(2)+'s';
            if(AppState.startTime) document.getElementById('metric-3').textContent = (this.transferred/((Date.now()-AppState.startTime)/1000/60)).toFixed(1); }
        getResults() { const tt = AppState.startTime?(Date.now()-AppState.startTime)/1000:0; return { blocksTransferred: this.transferred, totalTime: tt.toFixed(2), blocksPerMinute: (this.transferred/(tt/60)).toFixed(1) }; }
    }

/* --- COGNITIVE: TrailMakingModule (js/modules/cognitive/trailmaking.js) --- */
    class TrailMakingModule extends BaseModule {
        constructor(e) { super(e); this.targets = []; this.currentIndex = 0; this.errors = 0; this.lastGripState = false; }
        init() { this.engine.camera.position.set(0,15,0.1); this.engine.camera.lookAt(0,0,0);
            const labels = ['1','2','3','4','5','6','7','8','9','10','11','12'];
            for(let i=0; i<12; i++) { let x, z, valid; do { x = (Math.random()-0.5)*14; z = (Math.random()-0.5)*10; valid = true;
                for(const t of this.targets) if(Math.sqrt(Math.pow(x-t.position.x,2)+Math.pow(z-t.position.z,2))<2) valid = false; } while(!valid);
                const c = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.1,32), new THREE.MeshStandardMaterial({color:i===0?0x00ff88:0x2a2a35}));
                c.position.set(x, 0.05, z); c.userData = {index:i, label:labels[i], completed:false}; this.targets.push(c); this.addObject(c);
                const rim = new THREE.Mesh(new THREE.TorusGeometry(0.6,0.05,8,32), this.createGlowMaterial(i===0?0x00ff88:0x00d4ff, 0.3));
                rim.position.set(x, 0.1, z); rim.rotation.x = -Math.PI/2; c.userData.rim = rim; this.addObject(rim);
                const lbl = this.createTextSprite(labels[i], 0.5, '#ffffff'); lbl.position.set(x, 0.5, z); this.addObject(lbl); } }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0), grip = cd.right.gestures.grip, isG = grip?.clicked||false;
            if(isG && !this.lastGripState) { const t = this.targets[this.currentIndex]; if(t) { const d = Math.sqrt(Math.pow(wp.x-t.position.x,2)+Math.pow(wp.z-t.position.z,2));
                if(d<1) this.selectTarget(this.currentIndex); else { for(const tt of this.targets) { const dd = Math.sqrt(Math.pow(wp.x-tt.position.x,2)+Math.pow(wp.z-tt.position.z,2));
                    if(dd<1 && tt.userData.index!==this.currentIndex && !tt.userData.completed) { this.errors++; document.getElementById('metric-2').textContent = this.errors; tt.material.color.setHex(0xff006e); setTimeout(()=>tt.material.color.setHex(0x2a2a35),200); break; } } } } }
            this.lastGripState = isG; this.targets.forEach(t => { if(!t.userData.completed && t.userData.index===this.currentIndex) t.userData.rim.material.emissiveIntensity = 0.3+Math.sin(Date.now()*0.005)*0.2; });
            this.updateTimer(); document.getElementById('metric-3').textContent = ((Date.now()-AppState.startTime)/1000).toFixed(1)+'s';
            if(this.currentIndex >= this.targets.length) showResults('trailmaking', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; if(Math.floor(this.demoTime/0.8)>this.currentIndex && this.currentIndex<this.targets.length) this.selectTarget(this.currentIndex);
            this.updateTimer(); if(this.currentIndex>=this.targets.length) setTimeout(()=>stopAssessment(),1000); }
        selectTarget(i) { const t = this.targets[i]; if(!t) return; t.userData.completed = true; t.material.color.setHex(0x00ff88); t.userData.rim.material.color.setHex(0x00ff88); t.userData.rim.material.emissive.setHex(0x00ff88);
            if(i>0) { const p = this.targets[i-1], lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(p.position.x,0.15,p.position.z), new THREE.Vector3(t.position.x,0.15,t.position.z)]);
                this.addObject(new THREE.Line(lg, new THREE.LineBasicMaterial({color:0x00ff88}))); }
            this.currentIndex++; if(this.targets[this.currentIndex]) { this.targets[this.currentIndex].userData.rim.material.color.setHex(0xffd700); this.targets[this.currentIndex].userData.rim.material.emissive.setHex(0xffd700); }
            document.getElementById('metric-1').textContent = this.currentIndex; document.getElementById('score').textContent = this.currentIndex; }
        getResults() { return { completed: this.currentIndex, totalTime: ((Date.now()-AppState.startTime)/1000).toFixed(2), errors: this.errors }; }
    }

/* --- COGNITIVE: ReactionTimeModule (js/modules/cognitive/reactiontime.js) --- */
    class ReactionTimeModule extends BaseModule {
        constructor(e) { super(e); this.activeTarget = null; this.trialCount = 0; this.maxTrials = 15; this.reactionTimes = []; this.stimulusTime = null; this.waitingForResponse = false; this.lastGripState = false; }
        init() { this.engine.camera.position.set(0,8,12); this.engine.camera.lookAt(0,2,0);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(4,4,0.2,64), new THREE.MeshStandardMaterial({color:0x1a1a25})); p.position.y = 0.1; this.addObject(p);
            this.activeTarget = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), this.createGlowMaterial(0x00ff88, 0.8)); this.activeTarget.position.set(0,2,0); this.activeTarget.visible = false; this.addObject(this.activeTarget);
            const lbl = this.createTextSprite('WAIT FOR TARGET...', 0.6, '#ffd700'); lbl.position.set(0,5,0); this.addObject(lbl); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const grip = cd.right.gestures.grip; if(this.waitingForResponse && grip?.clicked && !this.lastGripState) this.onResponse(); this.lastGripState = grip?.clicked||false;
            if(this.activeTarget.visible) this.activeTarget.scale.setScalar(1+Math.sin(Date.now()*0.01)*0.1); this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const ph = this.demoTime%2; if(ph<0.5) this.activeTarget.visible = false;
            else if(ph<1.5 && !this.activeTarget.visible) this.showTarget(); else if(ph>=1.5 && this.waitingForResponse) this.onResponse();
            this.updateTimer(); if(this.trialCount>=this.maxTrials) setTimeout(()=>stopAssessment(),500); }
        start(d=false) { super.start(d); if(!d) setTimeout(()=>this.showTarget(),2000); }
        showTarget() { this.activeTarget.visible = true; this.activeTarget.position.x = (Math.random()-0.5)*4; this.activeTarget.position.z = (Math.random()-0.5)*4; this.stimulusTime = Date.now(); this.waitingForResponse = true;
            const colors = [0x00ff88,0x00d4ff,0xff006e,0xffd700], c = colors[Math.floor(Math.random()*colors.length)]; this.activeTarget.material.color.setHex(c); this.activeTarget.material.emissive.setHex(c); }
        onResponse() { if(!this.waitingForResponse) return; const rt = Date.now()-this.stimulusTime; this.reactionTimes.push(rt); this.trialCount++; this.waitingForResponse = false; this.activeTarget.visible = false;
            document.getElementById('score').textContent = this.trialCount; document.getElementById('metric-1').textContent = rt+'ms';
            document.getElementById('metric-2').textContent = (this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length).toFixed(0)+'ms';
            document.getElementById('metric-3').textContent = Math.min(...this.reactionTimes)+'ms';
            if(this.trialCount>=this.maxTrials) showResults('reactiontime', this.getResults()); else if(!this.isDemo) setTimeout(()=>{if(this.isRunning) this.showTarget();}, 1000+Math.random()*2000); }
        getResults() { const avg = this.reactionTimes.length>0?this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length:0;
            return { trials: this.trialCount, avgRT: avg.toFixed(0), minRT: Math.min(...this.reactionTimes), maxRT: Math.max(...this.reactionTimes) }; }
    }

/* --- COGNITIVE: StroopModule (js/modules/cognitive/stroop.js) --- */
    class StroopModule extends BaseModule {
        constructor(e) { super(e); this.words = ['RED','BLUE','GREEN','YELLOW']; this.colors = [0xff0000,0x0066ff,0x00cc00,0xffcc00]; this.currentInkColor = null; this.trialCount = 0; this.maxTrials = 20; this.correct = 0; this.reactionTimes = []; this.stimulusTime = null; this.wordSprite = null; this.lastGripState = false; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,3,0);
            const panel = new THREE.Mesh(new THREE.BoxGeometry(8,4,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); panel.position.set(0,4,-2); this.addObject(panel);
            this.wordSprite = this.createTextSprite('READY', 1.5, '#ffffff'); this.wordSprite.position.set(0,4,-1.5); this.addObject(this.wordSprite);
            const inst = this.createTextSprite('Name the INK COLOR!', 0.3, '#888888'); inst.position.set(0,6,-1.5); this.addObject(inst);
            [{label:'RED',color:0xff0000,x:-3},{label:'BLUE',color:0x0066ff,x:-1},{label:'GREEN',color:0x00cc00,x:1},{label:'YELLOW',color:0xffcc00,x:3}].forEach((btn,i) => {
                const b = new THREE.Mesh(new THREE.BoxGeometry(1.5,0.5,1), this.createGlowMaterial(btn.color,0.4)); b.position.set(btn.x,0.25,3); b.userData = {colorIndex:i}; this.addObject(b);
                const lbl = this.createTextSprite(btn.label, 0.3, '#ffffff'); lbl.position.set(btn.x,0.8,3); this.addObject(lbl); }); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.25), grip = cd.right.gestures.grip;
            if(grip?.clicked && !this.lastGripState && this.stimulusTime) { for(let i=0; i<4; i++) if(Math.sqrt(Math.pow(wp.x-(-3+i*2),2)+Math.pow(wp.z-3,2))<1) { this.onResponse(i); break; } }
            this.lastGripState = grip?.clicked||false; this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const ph = this.demoTime%1.5; if(ph<0.2 && !this.stimulusTime) this.showStimulus(); else if(ph>1.0 && this.stimulusTime) this.onResponse(this.currentInkColor);
            this.updateTimer(); if(this.trialCount>=this.maxTrials) setTimeout(()=>stopAssessment(),500); }
        start(d=false) { super.start(d); if(!d) setTimeout(()=>this.showStimulus(),1500); }
        showStimulus() { const wi = Math.floor(Math.random()*this.words.length); this.currentInkColor = Math.random()<0.7?(wi+1+Math.floor(Math.random()*3))%4:wi;
            const cv = document.createElement('canvas'), ctx = cv.getContext('2d'); cv.width = 512; cv.height = 256;
            ctx.fillStyle = '#'+this.colors[this.currentInkColor].toString(16).padStart(6,'0'); ctx.font = 'bold 120px Outfit'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.words[wi], 256, 128);
            this.wordSprite.material.map = new THREE.CanvasTexture(cv); this.wordSprite.material.needsUpdate = true; this.stimulusTime = Date.now(); }
        onResponse(ci) { const rt = Date.now()-this.stimulusTime; this.reactionTimes.push(rt); this.trialCount++; if(ci===this.currentInkColor) this.correct++;
            document.getElementById('score').textContent = this.correct; document.getElementById('metric-1').textContent = this.correct+'/'+this.trialCount;
            document.getElementById('metric-2').textContent = (this.correct/this.trialCount*100).toFixed(0)+'%';
            document.getElementById('metric-3').textContent = (this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length).toFixed(0)+'ms';
            this.stimulusTime = null; if(this.trialCount>=this.maxTrials) showResults('stroop', this.getResults()); else if(!this.isDemo) setTimeout(()=>this.showStimulus(),500); }
        getResults() { return { correct: this.correct, total: this.trialCount, accuracy: (this.correct/this.trialCount*100).toFixed(1)+'%', avgRT: (this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length).toFixed(0) }; }
    }

/* --- MOVEMENT: TremorModule (js/modules/movement/tremor.js) --- */
    class TremorModule extends BaseModule {
        constructor(e) { super(e); this.handModel = null; this.tremorData = []; this.graphBars = []; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,2,0);
            const zone = new THREE.Mesh(new THREE.TorusGeometry(1.5,0.1,8,64), this.createGlowMaterial(0x00d4ff, 0.5)); zone.position.set(0,3,0); zone.rotation.x = Math.PI/2; this.addObject(zone);
            this.handModel = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), this.createGlowMaterial(0x00ff88, 0.6)); this.handModel.position.set(0,3,0); this.addObject(this.handModel);
            const lbl = this.createTextSprite('HOLD STEADY', 0.5, '#00d4ff'); lbl.position.set(0,5.5,0); this.addObject(lbl);
            const graph = new THREE.Mesh(new THREE.BoxGeometry(10,2,0.1), new THREE.MeshStandardMaterial({color:0x1a1a25})); graph.position.set(0,-1,0); this.addObject(graph); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const tp = cd.right.trackpad||{x:127,y:127}, dev = Math.sqrt(Math.pow((tp.x-127)/127,2)+Math.pow((tp.y-127)/127,2)); this.tremorData.push(dev);
            this.handModel.position.x = Math.sin(Date.now()*0.05)*0.1*(1+dev); this.handModel.position.y = 3+Math.cos(Date.now()*0.03)*0.05;
            this.addGraphBar(dev); this.updateMetrics(); this.updateTimer(); if(AppState.startTime && (Date.now()-AppState.startTime)>30000) showResults('tremor', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; const freq = 5+Math.sin(this.demoTime*0.5)*2, amp = 0.2+Math.sin(this.demoTime*0.3)*0.1, x = Math.sin(this.demoTime*freq)*amp;
            this.handModel.position.x = x; this.handModel.position.y = 3+Math.cos(this.demoTime*freq*1.3)*amp*0.5; this.tremorData.push(Math.abs(x));
            this.addGraphBar(Math.abs(x)); this.updateMetrics(); this.updateTimer(); if(this.demoTime>15) stopAssessment(); }
        addGraphBar(dev) { if(this.tremorData.length%5===0 && this.graphBars.length<50) { const b = new THREE.Mesh(new THREE.BoxGeometry(0.15,dev*2+0.1,0.15), new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(0.3-dev,1,0.5)}));
            b.position.set(-4.5+this.graphBars.length*0.2, -1+dev, 0.1); this.graphBars.push(b); this.addObject(b); } }
        updateMetrics() { if(this.tremorData.length===0) return; const avg = this.tremorData.reduce((a,b)=>a+b,0)/this.tremorData.length;
            document.getElementById('score').textContent = Math.max(0,(1-avg)*100).toFixed(0)+'%';
            document.getElementById('metric-1').textContent = (avg*10).toFixed(2)+'Hz'; document.getElementById('metric-2').textContent = (avg*5).toFixed(2)+'mm'; document.getElementById('metric-3').textContent = Math.max(0,(1-avg)*100).toFixed(0)+'%'; }
        getResults() { const avg = this.tremorData.length>0?this.tremorData.reduce((a,b)=>a+b,0)/this.tremorData.length:0;
            return { stability: Math.max(0,(1-avg)*100).toFixed(1)+'%', avgDeviation: (avg*5).toFixed(2)+'mm', frequency: (avg*10).toFixed(2)+'Hz' }; }
    }

/* --- MOVEMENT: CoordinationModule (js/modules/movement/coordination.js) --- */
    class CoordinationModule extends BaseModule {
        constructor(e) { super(e); this.leftTarget = null; this.rightTarget = null; this.leftHand = null; this.rightHand = null; this.syncScores = []; this.phase = 0; }
        init() { this.engine.camera.position.set(0,8,12); this.engine.camera.lookAt(0,2,0);
            const pm = new THREE.MeshStandardMaterial({color:0x00d4ff, transparent:true, opacity:0.5});
            [{x:-4,c:0x00d4ff,l:'LEFT'},{x:4,c:0xa855f7,l:'RIGHT'}].forEach(p => { const path = new THREE.Mesh(new THREE.TorusGeometry(2,0.05,8,64), pm.clone()); path.position.set(p.x,2,0); path.rotation.x = Math.PI/2; this.addObject(path);
                const lbl = this.createTextSprite(p.l, 0.4, '#'+p.c.toString(16)); lbl.position.set(p.x,4.5,0); this.addObject(lbl); });
            this.leftTarget = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), this.createGlowMaterial(0x00d4ff, 0.6)); this.leftTarget.position.set(-2,2,0); this.addObject(this.leftTarget);
            this.rightTarget = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), this.createGlowMaterial(0xa855f7, 0.6)); this.rightTarget.position.set(6,2,0); this.addObject(this.rightTarget);
            this.leftHand = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16), this.createGlowMaterial(0x00ff88, 0.5)); this.leftHand.position.set(-4,2,0); this.addObject(this.leftHand);
            this.rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16), this.createGlowMaterial(0xff006e, 0.5)); this.rightHand.position.set(4,2,0); this.addObject(this.rightHand); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            this.phase += dt*2; this.leftTarget.position.x = -4+Math.cos(this.phase)*2; this.leftTarget.position.z = Math.sin(this.phase)*2;
            this.rightTarget.position.x = 4+Math.cos(this.phase)*2; this.rightTarget.position.z = Math.sin(this.phase)*2;
            const lt = cd.left.trackpad, rt = cd.right.trackpad; this.leftHand.position.x = -4+((lt.x-127)/127)*2; this.leftHand.position.z = ((lt.y-127)/127)*2;
            this.rightHand.position.x = 4+((rt.x-127)/127)*2; this.rightHand.position.z = ((rt.y-127)/127)*2;
            const ss = Math.max(0, 100-(this.leftHand.position.distanceTo(this.leftTarget.position)+this.rightHand.position.distanceTo(this.rightTarget.position))*25); this.syncScores.push(ss);
            this.updateMetrics(); this.updateTimer(); if(AppState.startTime && (Date.now()-AppState.startTime)>30000) showResults('coordination', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; this.phase += dt*2; this.leftTarget.position.x = -4+Math.cos(this.phase)*2; this.leftTarget.position.z = Math.sin(this.phase)*2;
            this.rightTarget.position.x = 4+Math.cos(this.phase)*2; this.rightTarget.position.z = Math.sin(this.phase)*2; const lag = 0.1;
            this.leftHand.position.x = -4+Math.cos(this.phase-lag)*2; this.leftHand.position.z = Math.sin(this.phase-lag)*2;
            this.rightHand.position.x = 4+Math.cos(this.phase-lag)*2; this.rightHand.position.z = Math.sin(this.phase-lag)*2;
            this.syncScores.push(Math.max(0, 100-(this.leftHand.position.distanceTo(this.leftTarget.position)+this.rightHand.position.distanceTo(this.rightTarget.position))*25));
            this.updateMetrics(); this.updateTimer(); if(this.demoTime>15) stopAssessment(); }
        updateMetrics() { const avg = this.syncScores.length>0?this.syncScores.reduce((a,b)=>a+b,0)/this.syncScores.length:0;
            document.getElementById('score').textContent = avg.toFixed(0)+'%'; document.getElementById('metric-1').textContent = avg.toFixed(1)+'%'; }
        getResults() { return { avgSync: (this.syncScores.reduce((a,b)=>a+b,0)/this.syncScores.length).toFixed(1)+'%', samples: this.syncScores.length }; }
    }

    // ============================================================================
    // RHYTHM SLASHER MODULE (Beat Saber-style)
    // ============================================================================

/* --- GAMIFIED: RhythmSlasherModule (js/modules/gamified/rhythmslash.js) --- */
    class RhythmSlasherModule extends BaseModule {
        constructor(e) { 
            super(e); 
            this.blocks = []; this.leftSaber = null; this.rightSaber = null;
            this.spawnTimer = 0; this.spawnInterval = 1.2; this.blockSpeed = 4;
            this.score = 0; this.combo = 0; this.maxCombo = 0; this.hits = 0; this.misses = 0;
            this.reactionTimes = []; this.slashVelocities = []; this.leftSlashes = 0; this.rightSlashes = 0;
            this.lastLeftPos = null; this.lastRightPos = null;
            this.leftTrail = []; this.rightTrail = [];
            this.beatPattern = []; this.patternIndex = 0;
            this.difficulty = 1;
        }
        
        init() {
            this.engine.camera.position.set(0, 3, 8);
            this.engine.camera.lookAt(0, 2, -10);
            
            // Dark tunnel environment
            const tunnelGeo = new THREE.BoxGeometry(8, 6, 50);
            const tunnelMat = new THREE.MeshStandardMaterial({ color: 0x0a0a15, side: THREE.BackSide });
            const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
            tunnel.position.set(0, 3, -20);
            this.addObject(tunnel);
            
            // Glowing floor grid
            const gridHelper = new THREE.GridHelper(8, 16, 0x00d4ff, 0x1a1a25);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            this.addObject(gridHelper);
            
            // Lane markers
            for (let i = -1; i <= 1; i += 2) {
                const laneMat = new THREE.MeshStandardMaterial({ color: i < 0 ? 0x00d4ff : 0xa855f7, emissive: i < 0 ? 0x00d4ff : 0xa855f7, emissiveIntensity: 0.2, transparent: true, opacity: 0.3 });
                const lane = new THREE.Mesh(new THREE.PlaneGeometry(2, 50), laneMat);
                lane.rotation.x = -Math.PI / 2;
                lane.position.set(i * 1.5, 0.02, -20);
                this.addObject(lane);
            }
            
            // Create sabers
            this.createSabers();
            
            // HUD elements
            const comboLabel = this.createTextSprite('COMBO', 0.3, '#ffd700');
            comboLabel.position.set(0, 5.5, -5);
            this.addObject(comboLabel);
            
            // Generate beat pattern
            this.generateBeatPattern();
            
            // Spawn zone indicator
            const spawnLine = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.05, 0.1),
                new THREE.MeshStandardMaterial({ color: 0xff006e, emissive: 0xff006e, emissiveIntensity: 0.8 })
            );
            spawnLine.position.set(0, 0.5, 2);
            this.addObject(spawnLine);
        }
        
        createSabers() {
            // Left saber (blue/cyan)
            const leftGroup = new THREE.Group();
            const leftBlade = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 1.2, 0.08),
                new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 0.9, transparent: true, opacity: 0.9 })
            );
            leftBlade.position.y = 0.6;
            const leftHandle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.06, 0.25, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 })
            );
            leftHandle.position.y = -0.05;
            leftGroup.add(leftBlade);
            leftGroup.add(leftHandle);
            leftGroup.position.set(-1.5, 2, 4);
            this.leftSaber = leftGroup;
            this.addObject(leftGroup);
            
            // Right saber (purple/magenta)
            const rightGroup = new THREE.Group();
            const rightBlade = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 1.2, 0.08),
                new THREE.MeshStandardMaterial({ color: 0xa855f7, emissive: 0xa855f7, emissiveIntensity: 0.9, transparent: true, opacity: 0.9 })
            );
            rightBlade.position.y = 0.6;
            const rightHandle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.06, 0.25, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 })
            );
            rightHandle.position.y = -0.05;
            rightGroup.add(rightBlade);
            rightGroup.add(rightHandle);
            rightGroup.position.set(1.5, 2, 4);
            this.rightSaber = rightGroup;
            this.addObject(rightGroup);
            
            // Trail effects
            for (let i = 0; i < 10; i++) {
                const trailL = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.5 - i * 0.05 })
                );
                trailL.visible = false;
                this.leftTrail.push(trailL);
                this.addObject(trailL);
                
                const trailR = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xa855f7, transparent: true, opacity: 0.5 - i * 0.05 })
                );
                trailR.visible = false;
                this.rightTrail.push(trailR);
                this.addObject(trailR);
            }
        }
        
        generateBeatPattern() {
            // Create a sequence of blocks with timing
            // Format: { time, lane (-1=left, 1=right, 0=center), height (0-2), direction }
            const patterns = [
                // Simple alternating
                { t: 0, lane: -1, h: 1, dir: 'down' },
                { t: 1.2, lane: 1, h: 1, dir: 'down' },
                { t: 2.4, lane: -1, h: 1.5, dir: 'left' },
                { t: 3.6, lane: 1, h: 1.5, dir: 'right' },
                { t: 4.8, lane: -1, h: 0.5, dir: 'up' },
                { t: 6.0, lane: 1, h: 0.5, dir: 'up' },
                // Simultaneous
                { t: 7.2, lane: -1, h: 1, dir: 'down' },
                { t: 7.2, lane: 1, h: 1, dir: 'down' },
                // Faster section
                { t: 8.4, lane: -1, h: 1.2, dir: 'down' },
                { t: 9.0, lane: 1, h: 0.8, dir: 'down' },
                { t: 9.6, lane: -1, h: 1.5, dir: 'left' },
                { t: 10.2, lane: 1, h: 1.5, dir: 'right' },
                { t: 10.8, lane: -1, h: 1, dir: 'down' },
                { t: 10.8, lane: 1, h: 1, dir: 'down' },
                // Cross pattern
                { t: 12.0, lane: 0, h: 1, dir: 'down' },
                { t: 12.6, lane: -1, h: 1.5, dir: 'down' },
                { t: 12.6, lane: 1, h: 0.5, dir: 'up' },
                { t: 13.2, lane: -1, h: 0.5, dir: 'up' },
                { t: 13.2, lane: 1, h: 1.5, dir: 'down' },
                // Finale
                { t: 14.4, lane: -1, h: 1, dir: 'down' },
                { t: 14.7, lane: 1, h: 1, dir: 'down' },
                { t: 15.0, lane: -1, h: 1.2, dir: 'down' },
                { t: 15.3, lane: 1, h: 1.2, dir: 'down' },
                { t: 15.6, lane: -1, h: 1, dir: 'left' },
                { t: 15.6, lane: 1, h: 1, dir: 'right' },
            ];
            this.beatPattern = patterns;
        }
        
        spawnBlock(lane, height, direction) {
            const isLeft = lane <= 0;
            const color = isLeft ? 0x00d4ff : 0xa855f7;
            
            const blockGroup = new THREE.Group();
            
            // Main block
            const blockGeo = new THREE.BoxGeometry(0.6, 0.6, 0.3);
            const blockMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color, 
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.7
            });
            const block = new THREE.Mesh(blockGeo, blockMat);
            blockGroup.add(block);
            
            // Direction arrow
            const arrowGeo = new THREE.ConeGeometry(0.15, 0.3, 4);
            const arrowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 });
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.z = 0.2;
            
            // Rotate arrow based on direction
            switch(direction) {
                case 'up': arrow.rotation.x = Math.PI; break;
                case 'down': arrow.rotation.x = 0; break;
                case 'left': arrow.rotation.z = -Math.PI/2; arrow.rotation.x = Math.PI/2; break;
                case 'right': arrow.rotation.z = Math.PI/2; arrow.rotation.x = Math.PI/2; break;
            }
            blockGroup.add(arrow);
            
            // Position
            blockGroup.position.set(lane * 1.5, 0.5 + height, -40);
            blockGroup.userData = { 
                lane, height, direction, isLeft, 
                spawnTime: Date.now(), 
                hit: false, 
                speed: this.blockSpeed 
            };
            
            this.blocks.push(blockGroup);
            this.addObject(blockGroup);
        }
        
        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;
            
            const lt = cd.left?.trackpad || { x: 127, y: 127 };
            const rt = cd.right?.trackpad || { x: 127, y: 127 };
            const lg = cd.left?.gestures?.grip || { pull: 0 };
            const rg = cd.right?.gestures?.grip || { pull: 0 };
            
            // Update saber positions based on trackpad
            const lx = (lt.x - 127) / 127;
            const ly = (lt.y - 127) / 127;
            const rx = (rt.x - 127) / 127;
            const ry = (rt.y - 127) / 127;
            
            // Saber positions
            this.leftSaber.position.x = -1.5 + lx * 1.5;
            this.leftSaber.position.y = 2 + ly * 1.5;
            this.leftSaber.rotation.z = lx * 0.5;
            this.leftSaber.rotation.x = -ly * 0.3;
            
            this.rightSaber.position.x = 1.5 + rx * 1.5;
            this.rightSaber.position.y = 2 + ry * 1.5;
            this.rightSaber.rotation.z = rx * 0.5;
            this.rightSaber.rotation.x = -ry * 0.3;
            
            // Sync avatar arms with saber positions
            this.syncAvatarWithSabers();
            
            // Calculate velocities for slash detection
            const leftVel = this.lastLeftPos ? 
                Math.sqrt(Math.pow(this.leftSaber.position.x - this.lastLeftPos.x, 2) + Math.pow(this.leftSaber.position.y - this.lastLeftPos.y, 2)) / dt : 0;
            const rightVel = this.lastRightPos ? 
                Math.sqrt(Math.pow(this.rightSaber.position.x - this.lastRightPos.x, 2) + Math.pow(this.rightSaber.position.y - this.lastRightPos.y, 2)) / dt : 0;
            
            this.lastLeftPos = this.leftSaber.position.clone();
            this.lastRightPos = this.rightSaber.position.clone();
            
            // Update trails
            this.updateTrail(this.leftTrail, this.leftSaber.position);
            this.updateTrail(this.rightTrail, this.rightSaber.position);
            
            // Spawn blocks based on pattern
            this.updateSpawning(dt);
            
            // Update blocks
            this.updateBlocks(dt, leftVel, rightVel);
            
            this.updateMetrics();
            this.updateTimer();
            
            // End after pattern completes
            if (AppState.startTime && (Date.now() - AppState.startTime) > 20000) {
                showResults('rhythmslash', this.getResults());
            }
        }
        
        updateTrail(trail, pos) {
            for (let i = trail.length - 1; i > 0; i--) {
                trail[i].position.copy(trail[i-1].position);
                trail[i].visible = trail[i-1].visible;
            }
            trail[0].position.copy(pos);
            trail[0].position.y += 0.6;
            trail[0].visible = true;
        }
        
        updateSpawning(dt) {
            const elapsed = (Date.now() - AppState.startTime) / 1000;
            
            while (this.patternIndex < this.beatPattern.length && 
                   this.beatPattern[this.patternIndex].t <= elapsed) {
                const p = this.beatPattern[this.patternIndex];
                this.spawnBlock(p.lane, p.h, p.dir);
                this.patternIndex++;
            }
        }
        
        updateBlocks(dt, leftVel, rightVel) {
            for (let i = this.blocks.length - 1; i >= 0; i--) {
                const block = this.blocks[i];
                block.position.z += block.userData.speed * dt;
                
                // Rotation effect as it approaches
                block.rotation.y += dt * 0.5;
                
                // Check collision with sabers
                if (!block.userData.hit) {
                    const saber = block.userData.isLeft ? this.leftSaber : this.rightSaber;
                    const vel = block.userData.isLeft ? leftVel : rightVel;
                    const dist = block.position.distanceTo(saber.position);
                    
                    if (dist < 0.8 && vel > 0.5) {
                        // HIT!
                        this.onBlockHit(block, vel);
                    }
                }
                
                // Remove if past player
                if (block.position.z > 6) {
                    if (!block.userData.hit) {
                        this.onBlockMiss(block);
                    }
                    this.scene.remove(block);
                    this.blocks.splice(i, 1);
                }
            }
        }
        
        onBlockHit(block, velocity) {
            block.userData.hit = true;
            this.hits++;
            this.combo++;
            this.maxCombo = Math.max(this.maxCombo, this.combo);
            
            // Score based on timing and velocity
            const rt = Date.now() - block.userData.spawnTime;
            this.reactionTimes.push(rt);
            this.slashVelocities.push(velocity);
            
            if (block.userData.isLeft) this.leftSlashes++;
            else this.rightSlashes++;
            
            const points = Math.floor(100 * (1 + this.combo * 0.1) * Math.min(2, velocity));
            this.score += points;
            
            // Visual feedback - explode block
            this.explodeBlock(block);
        }
        
        onBlockMiss(block) {
            this.misses++;
            this.combo = 0;
        }
        
        explodeBlock(block) {
            const color = block.userData.isLeft ? 0x00d4ff : 0xa855f7;
            
            // Create particles
            for (let i = 0; i < 8; i++) {
                const particle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 })
                );
                particle.position.copy(block.position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5 + 2,
                    (Math.random() - 0.5) * 2
                );
                particle.userData.life = 0.5;
                this.addObject(particle);
                
                // Animate particle
                const animateParticle = () => {
                    particle.userData.life -= 0.016;
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        return;
                    }
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));
                    particle.userData.velocity.y -= 9.8 * 0.016;
                    particle.material.opacity = particle.userData.life * 2;
                    particle.rotation.x += 0.1;
                    particle.rotation.y += 0.1;
                    requestAnimationFrame(animateParticle);
                };
                animateParticle();
            }
            
            // Hide original block
            block.visible = false;
        }
        
        syncAvatarWithSabers() {
            if (!this.engine.avatar || !this.engine.avatar.visible) return;
            
            const avatar = this.engine.avatar;
            
            // Convert saber world positions to avatar-relative positions for arm IK
            // Avatar is at (-4, 0, 6) rotated slightly, sabers are in game space
            const avatarPos = avatar.group.position;
            
            // Map saber positions to trackpad-like values for the avatar
            // Left saber: x range [-3, 0], y range [0.5, 3.5]
            // Right saber: x range [0, 3], y range [0.5, 3.5]
            
            const lx = ((this.leftSaber.position.x + 1.5) / 1.5); // -1 to 1
            const ly = ((this.leftSaber.position.y - 2) / 1.5); // -1 to 1
            const rx = ((this.rightSaber.position.x - 1.5) / 1.5); // -1 to 1
            const ry = ((this.rightSaber.position.y - 2) / 1.5); // -1 to 1
            
            // Update avatar arm targets
            const shoulder_l = avatar.joints.shoulder_l.position;
            const shoulder_r = avatar.joints.shoulder_r.position;
            
            // Extended arm positions for saber holding
            const leftTarget = new THREE.Vector3(
                shoulder_l.x - 0.3 + lx * 0.4,
                shoulder_l.y + ly * 0.5,
                0.4 + Math.abs(ly) * 0.2
            );
            
            const rightTarget = new THREE.Vector3(
                shoulder_r.x + 0.3 + rx * 0.4,
                shoulder_r.y + ry * 0.5,
                0.4 + Math.abs(ry) * 0.2
            );
            
            avatar.solveArmIK('l', leftTarget);
            avatar.solveArmIK('r', rightTarget);
            
            // Update avatar controllers to look like they're holding sabers
            avatar.leftCtrl.position.copy(avatar.joints.wrist_l.position);
            avatar.leftCtrl.position.y -= 0.05;
            avatar.leftCtrl.rotation.set(ly * 0.5, 0, this.leftSaber.rotation.z);
            
            avatar.rightCtrl.position.copy(avatar.joints.wrist_r.position);
            avatar.rightCtrl.position.y -= 0.05;
            avatar.rightCtrl.rotation.set(ry * 0.5, 0, this.rightSaber.rotation.z);
            
            // Make controller glow more intensely during slashing
            const leftVel = this.lastLeftPos ? 
                this.leftSaber.position.distanceTo(this.lastLeftPos) * 10 : 0;
            const rightVel = this.lastRightPos ? 
                this.rightSaber.position.distanceTo(this.lastRightPos) * 10 : 0;
            
            avatar.leftCtrl.material.emissiveIntensity = 0.4 + Math.min(0.6, leftVel);
            avatar.rightCtrl.material.emissiveIntensity = 0.4 + Math.min(0.6, rightVel);
            
            // Curl fingers like gripping sabers
            avatar.leftFingers.forEach(f => { f.rotation.x = Math.PI * 0.35; });
            avatar.rightFingers.forEach(f => { f.rotation.x = Math.PI * 0.35; });
            
            avatar.updateLimbs();
        }
        
        runDemo(dt) {
            this.demoTime += dt;
            
            // Simulate trackpad movement following blocks
            const targetBlock = this.blocks.find(b => !b.userData.hit && b.position.z > -5);
            
            if (targetBlock) {
                // Move appropriate saber toward block
                const saber = targetBlock.userData.isLeft ? this.leftSaber : this.rightSaber;
                const targetX = targetBlock.position.x;
                const targetY = targetBlock.position.y;
                
                saber.position.x += (targetX - saber.position.x) * 0.1;
                saber.position.y += (targetY - saber.position.y) * 0.1;
                
                // Check for hit
                if (saber.position.distanceTo(targetBlock.position) < 0.8 && targetBlock.position.z > 2) {
                    this.onBlockHit(targetBlock, 2);
                }
            }
            
            // Update sabers with some motion
            this.leftSaber.rotation.z = Math.sin(this.demoTime * 3) * 0.2;
            this.rightSaber.rotation.z = Math.sin(this.demoTime * 3 + Math.PI) * 0.2;
            
            // Sync avatar with saber positions
            this.syncAvatarWithSabers();
            
            // Update trails
            this.updateTrail(this.leftTrail, this.leftSaber.position);
            this.updateTrail(this.rightTrail, this.rightSaber.position);
            
            // Spawn and update blocks
            this.updateSpawning(dt);
            this.updateBlocks(dt, 2, 2);
            
            this.updateMetrics();
            this.updateTimer();
            
            if (this.demoTime > 18) stopAssessment();
        }
        
        updateMetrics() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('metric-1').textContent = this.hits + '/' + (this.hits + this.misses);
            document.getElementById('metric-2').textContent = this.combo + 'x';
            if (this.reactionTimes.length > 0) {
                const avgRT = this.reactionTimes.reduce((a,b) => a+b, 0) / this.reactionTimes.length;
                document.getElementById('metric-3').textContent = avgRT.toFixed(0) + 'ms';
            }
        }
        
        getResults() {
            const avgRT = this.reactionTimes.length > 0 ? 
                this.reactionTimes.reduce((a,b) => a+b, 0) / this.reactionTimes.length : 0;
            const avgVel = this.slashVelocities.length > 0 ? 
                this.slashVelocities.reduce((a,b) => a+b, 0) / this.slashVelocities.length : 0;
            const accuracy = this.hits + this.misses > 0 ? 
                (this.hits / (this.hits + this.misses) * 100) : 0;
            const symmetry = Math.min(this.leftSlashes, this.rightSlashes) / 
                Math.max(this.leftSlashes, this.rightSlashes, 1) * 100;
            
            return {
                score: this.score,
                hits: this.hits,
                misses: this.misses,
                accuracy: accuracy.toFixed(1) + '%',
                maxCombo: this.maxCombo,
                avgReactionTime: avgRT.toFixed(0) + 'ms',
                avgSlashVelocity: avgVel.toFixed(2),
                leftSlashes: this.leftSlashes,
                rightSlashes: this.rightSlashes,
                symmetry: symmetry.toFixed(1) + '%'
            };
        }
    }

    // ============================================================================
    // COLOR SORT MODULE (Tetris-style Cognitive Game)
    // ============================================================================

/* --- GAMIFIED: ColorSortModule (js/modules/gamified/colorsort.js) --- */
    class ColorSortModule extends BaseModule {
        constructor(e) {
            super(e);
            this.blocks = [];
            this.bins = [];
            this.neutralBin = null;
            this.heldBlock = null;
            this.seenColors = new Set();
            this.colors = [
                { name: 'red', hex: 0xff4444 },
                { name: 'blue', hex: 0x4488ff },
                { name: 'green', hex: 0x44dd44 },
                { name: 'yellow', hex: 0xffdd44 },
                { name: 'purple', hex: 0xaa44ff }
            ];
            this.score = 0;
            this.correctPlacements = 0;
            this.repeatRecognitions = 0;
            this.memoryErrors = 0;
            this.ruleErrors = 0;
            this.missedBlocks = 0;
            this.reactionTimes = [];
            this.spawnTimer = 0;
            this.spawnInterval = 2.5;
            this.fallSpeed = 2;
            this.lastGrip = false;
            this.difficulty = 1;
            this.roundColors = []; // Track color sequence for current round
        }

        init() {
            this.engine.camera.position.set(0, 10, 14);
            this.engine.camera.lookAt(0, 3, 0);

            // Create floor/play area
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(16, 12),
                new THREE.MeshStandardMaterial({ color: 0x1a1a25, roughness: 0.9 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            this.addObject(floor);

            // Create the 5 colored bins
            const binWidth = 2;
            const binSpacing = 2.5;
            const startX = -5;

            for (let i = 0; i < 5; i++) {
                const color = this.colors[i];
                const binGroup = new THREE.Group();

                // Bin base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(binWidth, 0.3, 2),
                    new THREE.MeshStandardMaterial({ color: color.hex, emissive: color.hex, emissiveIntensity: 0.2 })
                );
                base.position.y = 0.15;
                binGroup.add(base);

                // Bin walls (open top box)
                const wallMat = new THREE.MeshStandardMaterial({ color: color.hex, emissive: color.hex, emissiveIntensity: 0.1, transparent: true, opacity: 0.7 });
                const backWall = new THREE.Mesh(new THREE.BoxGeometry(binWidth, 1.5, 0.1), wallMat);
                backWall.position.set(0, 0.75, -1);
                binGroup.add(backWall);
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), wallMat);
                leftWall.position.set(-binWidth/2, 0.75, 0);
                binGroup.add(leftWall);
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), wallMat);
                rightWall.position.set(binWidth/2, 0.75, 0);
                binGroup.add(rightWall);
                const frontWall = new THREE.Mesh(new THREE.BoxGeometry(binWidth, 0.5, 0.1), wallMat);
                frontWall.position.set(0, 0.25, 1);
                binGroup.add(frontWall);

                // Label
                const label = this.createTextSprite(color.name.toUpperCase(), 0.25, '#' + color.hex.toString(16).padStart(6, '0'));
                label.position.set(0, 2, 0);
                binGroup.add(label);

                binGroup.position.set(startX + i * binSpacing, 0, -3);
                binGroup.userData = { colorIndex: i, colorName: color.name, colorHex: color.hex };
                this.bins.push(binGroup);
                this.addObject(binGroup);
            }

            // Create NEUTRAL bin (center, elevated, distinct)
            const neutralGroup = new THREE.Group();
            const neutralBase = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.3, 2),
                new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.3 })
            );
            neutralBase.position.y = 0.15;
            neutralGroup.add(neutralBase);

            const neutralWallMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0xffffff, emissiveIntensity: 0.1, transparent: true, opacity: 0.6 });
            const nBackWall = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 0.1), neutralWallMat);
            nBackWall.position.set(0, 0.75, -1);
            neutralGroup.add(nBackWall);
            const nLeftWall = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), neutralWallMat);
            nLeftWall.position.set(-1.5, 0.75, 0);
            neutralGroup.add(nLeftWall);
            const nRightWall = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), neutralWallMat);
            nRightWall.position.set(1.5, 0.75, 0);
            neutralGroup.add(nRightWall);

            // Neutral label with special styling
            const neutralLabel = this.createTextSprite('NEUTRAL', 0.3, '#ffffff');
            neutralLabel.position.set(0, 2.2, 0);
            neutralGroup.add(neutralLabel);
            const repeatLabel = this.createTextSprite('(REPEATS)', 0.2, '#aaaaaa');
            repeatLabel.position.set(0, 1.8, 0);
            neutralGroup.add(repeatLabel);

            neutralGroup.position.set(0, 0, 3);
            neutralGroup.userData = { isNeutral: true };
            this.neutralBin = neutralGroup;
            this.addObject(neutralGroup);

            // Spawn zone indicator
            const spawnLine = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.05, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 0.5, transparent: true, opacity: 0.5 })
            );
            spawnLine.position.set(0, 8, 0);
            this.addObject(spawnLine);

            // Instructions HUD
            const instrLabel = this.createTextSprite('SORT BY COLOR ‚Ä¢ REPEATS GO TO NEUTRAL', 0.25, '#00d4ff');
            instrLabel.position.set(0, 9.5, 0);
            this.addObject(instrLabel);

            // Hand/cursor indicator
            this.hand = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 })
            );
            this.hand.position.set(0, 5, 5);
            this.addObject(this.hand);
        }

        spawnBlock() {
            // Pick a random color (with slight bias toward recently seen for challenge)
            let colorIndex;
            if (this.seenColors.size >= 3 && Math.random() < 0.4) {
                // 40% chance to repeat a seen color
                const seenArray = Array.from(this.seenColors);
                colorIndex = seenArray[Math.floor(Math.random() * seenArray.length)];
            } else {
                colorIndex = Math.floor(Math.random() * 5);
            }

            const color = this.colors[colorIndex];
            const isRepeat = this.seenColors.has(colorIndex);

            const block = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ 
                    color: color.hex, 
                    emissive: color.hex, 
                    emissiveIntensity: 0.4,
                    metalness: 0.3,
                    roughness: 0.6
                })
            );

            // Random X position
            const xPos = (Math.random() - 0.5) * 10;
            block.position.set(xPos, 9, 0);
            block.userData = {
                colorIndex: colorIndex,
                colorName: color.name,
                colorHex: color.hex,
                isRepeat: isRepeat,
                spawnTime: Date.now(),
                grabbed: false
            };

            // Track that we've seen this color
            if (!isRepeat) {
                this.seenColors.add(colorIndex);
            }
            this.roundColors.push({ colorIndex, isRepeat });

            this.blocks.push(block);
            this.addObject(block);

            // Difficulty scaling
            if (this.correctPlacements + this.repeatRecognitions > 5) {
                this.spawnInterval = Math.max(1.5, this.spawnInterval - 0.1);
                this.fallSpeed = Math.min(4, this.fallSpeed + 0.1);
            }
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            const lt = cd.left?.trackpad || { x: 127, y: 127 };
            const grip = cd.right?.gestures?.grip?.pull || cd.left?.gestures?.grip?.pull || 0;
            const isGripping = grip > 50;

            // Update hand position
            const handX = ((lt.x - 127) / 127) * 7;
            const handY = 3 + ((255 - lt.y) / 255) * 6;
            this.hand.position.x = handX;
            this.hand.position.y = handY;
            this.hand.material.emissiveIntensity = isGripping ? 1 : 0.5;

            // Spawn blocks
            this.spawnTimer += dt;
            if (this.spawnTimer >= this.spawnInterval) {
                this.spawnBlock();
                this.spawnTimer = 0;
            }

            // Update blocks
            for (let i = this.blocks.length - 1; i >= 0; i--) {
                const block = this.blocks[i];

                if (this.heldBlock === block) {
                    // Block follows hand
                    block.position.x = this.hand.position.x;
                    block.position.y = this.hand.position.y - 0.5;
                    block.rotation.y += dt * 2;

                    // Check for bin placement on release
                    if (!isGripping && this.lastGrip) {
                        this.placeBlock(block);
                    }
                } else if (!block.userData.grabbed) {
                    // Block is falling
                    block.position.y -= this.fallSpeed * dt;
                    block.rotation.x += dt;
                    block.rotation.z += dt * 0.5;

                    // Check for grab
                    if (isGripping && !this.lastGrip && !this.heldBlock) {
                        const dist = this.hand.position.distanceTo(block.position);
                        if (dist < 1.5) {
                            this.heldBlock = block;
                            block.userData.grabbed = true;
                            const rt = Date.now() - block.userData.spawnTime;
                            this.reactionTimes.push(rt);
                        }
                    }

                    // Block missed (fell too low)
                    if (block.position.y < 0.5) {
                        this.missedBlocks++;
                        this.score = Math.max(0, this.score - 1);
                        this.createFeedback(block.position, false, 'MISSED!');
                        this.scene.remove(block);
                        this.blocks.splice(i, 1);
                    }
                }
            }

            this.lastGrip = isGripping;
            this.updateMetrics();
            this.updateTimer();

            // End after time limit
            if (AppState.startTime && (Date.now() - AppState.startTime) > 60000) {
                showResults('colorsort', this.getResults());
            }
        }

        placeBlock(block) {
            // Check which bin the block is over
            let placedIn = null;
            let correct = false;

            // Check neutral bin first
            if (Math.abs(block.position.x - this.neutralBin.position.x) < 2 &&
                Math.abs(block.position.z - this.neutralBin.position.z) < 2) {
                placedIn = 'neutral';
                if (block.userData.isRepeat) {
                    correct = true;
                    this.repeatRecognitions++;
                    this.score += 15; // Bonus for correct repeat recognition
                } else {
                    this.ruleErrors++;
                    this.score = Math.max(0, this.score - 2);
                }
            } else {
                // Check colored bins
                for (const bin of this.bins) {
                    if (Math.abs(block.position.x - bin.position.x) < 1.5 &&
                        Math.abs(block.position.z - bin.position.z) < 2) {
                        placedIn = bin.userData.colorName;
                        
                        if (block.userData.isRepeat) {
                            // Should have gone to neutral!
                            this.memoryErrors++;
                            this.score = Math.max(0, this.score - 2);
                        } else if (block.userData.colorIndex === bin.userData.colorIndex) {
                            correct = true;
                            this.correctPlacements++;
                            this.score += 10;
                        } else {
                            this.ruleErrors++;
                            this.score = Math.max(0, this.score - 1);
                        }
                        break;
                    }
                }
            }

            if (!placedIn) {
                // Dropped outside bins
                this.missedBlocks++;
                this.score = Math.max(0, this.score - 1);
                this.createFeedback(block.position, false, 'MISS!');
            } else {
                const msg = correct ? '+' + (block.userData.isRepeat ? '15' : '10') : 
                           (block.userData.isRepeat ? 'REPEAT!' : 'WRONG!');
                this.createFeedback(block.position, correct, msg);
            }

            // Remove block
            const idx = this.blocks.indexOf(block);
            if (idx > -1) {
                this.scene.remove(block);
                this.blocks.splice(idx, 1);
            }
            this.heldBlock = null;
        }

        createFeedback(position, success, text) {
            const color = success ? '#00ff88' : '#ff4444';
            const sprite = this.createTextSprite(text, 0.4, color);
            sprite.position.copy(position);
            sprite.position.y += 1;
            this.addObject(sprite);

            // Animate and remove
            let life = 1;
            const animate = () => {
                life -= 0.02;
                if (life <= 0) {
                    this.scene.remove(sprite);
                    return;
                }
                sprite.position.y += 0.05;
                sprite.material.opacity = life;
                requestAnimationFrame(animate);
            };
            animate();

            // Flash the appropriate bin
            if (success) {
                // Could add bin glow effect here
            }
        }

        runDemo(dt) {
            this.demoTime += dt;

            // Initialize scripted demo
            if (!this.demoSequence) {
                this.demoSequence = [
                    { colorIndex: 0, action: 'correct' },      // Red -> Red bin
                    { colorIndex: 1, action: 'correct' },      // Blue -> Blue bin  
                    { colorIndex: 2, action: 'correct' },      // Green -> Green bin
                    { colorIndex: 0, action: 'neutral' },      // Red REPEAT -> Neutral
                    { colorIndex: 3, action: 'wrong_bin' },    // Yellow -> wrong bin (error)
                    { colorIndex: 4, action: 'correct' },      // Purple -> Purple bin
                    { colorIndex: 1, action: 'memory_error' }, // Blue REPEAT -> Blue (should be neutral)
                    { colorIndex: 2, action: 'neutral' },      // Green REPEAT -> Neutral
                ];
                this.seqIndex = 0;
                this.phase = 'wait';
                this.phaseTimer = 0;
                this.currentBlock = null;
                this.targetBin = null;
            }

            this.phaseTimer += dt;

            // Demo complete
            if (this.seqIndex >= this.demoSequence.length) {
                if (this.phaseTimer > 2) stopAssessment();
                this.updateMetrics();
                this.updateTimer();
                return;
            }

            const entry = this.demoSequence[this.seqIndex];

            // Phase: Wait before spawning
            if (this.phase === 'wait') {
                if (this.phaseTimer > 0.5) {
                    // Spawn block
                    const color = this.colors[entry.colorIndex];
                    const isRepeat = this.seenColors.has(entry.colorIndex);
                    
                    const block = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 1.2, 1.2),
                        new THREE.MeshStandardMaterial({ color: color.hex, emissive: color.hex, emissiveIntensity: 0.5 })
                    );
                    block.position.set((Math.random()-0.5)*4, 8, 0);
                    block.userData = { colorIndex: entry.colorIndex, isRepeat: isRepeat, spawnTime: Date.now() };
                    
                    if (!isRepeat) this.seenColors.add(entry.colorIndex);
                    this.blocks.push(block);
                    this.addObject(block);
                    this.currentBlock = block;
                    
                    // Show REPEAT indicator
                    if (isRepeat) {
                        const ind = this.createTextSprite('REPEAT!', 0.4, '#ffaa00');
                        ind.position.set(block.position.x, 9.5, 0);
                        this.addObject(ind);
                        let indLife = 60;
                        const fadeInd = () => { if(--indLife <= 0) { this.scene.remove(ind); return; } ind.material.opacity = indLife/60; requestAnimationFrame(fadeInd); };
                        fadeInd();
                    }
                    
                    this.phase = 'fall';
                    this.phaseTimer = 0;
                }
            }

            // Phase: Block falling, hand chasing
            if (this.phase === 'fall' && this.currentBlock) {
                // Block falls
                this.currentBlock.position.y -= 2 * dt;
                this.currentBlock.rotation.x += dt;
                
                // Hand moves toward block
                this.hand.position.x += (this.currentBlock.position.x - this.hand.position.x) * 0.1;
                this.hand.position.y += (this.currentBlock.position.y - this.hand.position.y) * 0.1;
                this.hand.material.emissiveIntensity = 0.8;
                
                // Grab when close or block low enough
                if (this.currentBlock.position.y < 5 || this.hand.position.distanceTo(this.currentBlock.position) < 1) {
                    this.reactionTimes.push(Date.now() - this.currentBlock.userData.spawnTime);
                    
                    // Determine target bin
                    if (entry.action === 'correct') {
                        this.targetBin = this.bins[entry.colorIndex];
                    } else if (entry.action === 'neutral') {
                        this.targetBin = this.neutralBin;
                    } else if (entry.action === 'wrong_bin') {
                        this.targetBin = this.bins[(entry.colorIndex + 2) % 5];
                    } else if (entry.action === 'memory_error') {
                        this.targetBin = this.bins[entry.colorIndex];
                    }
                    
                    this.phase = 'carry';
                    this.phaseTimer = 0;
                }
            }

            // Phase: Carrying block to bin
            if (this.phase === 'carry' && this.currentBlock && this.targetBin) {
                const tx = this.targetBin.position.x;
                const tz = this.targetBin.position.z;
                
                // Hand moves to bin
                this.hand.position.x += (tx - this.hand.position.x) * 0.08;
                this.hand.position.y += (2 - this.hand.position.y) * 0.08;
                this.hand.material.emissiveIntensity = 1;
                
                // Block follows hand
                this.currentBlock.position.x = this.hand.position.x;
                this.currentBlock.position.y = this.hand.position.y + 0.5;
                this.currentBlock.rotation.y += dt * 2;
                
                // Drop when over bin
                if (Math.abs(this.hand.position.x - tx) < 1 && this.phaseTimer > 1) {
                    this.phase = 'drop';
                    this.phaseTimer = 0;
                }
            }

            // Phase: Dropping into bin
            if (this.phase === 'drop' && this.currentBlock) {
                this.currentBlock.position.y -= 5 * dt;
                
                if (this.currentBlock.position.y < 1) {
                    // Evaluate placement
                    this.placeBlock(this.currentBlock);
                    
                    // Reset
                    this.currentBlock = null;
                    this.targetBin = null;
                    this.hand.position.set(0, 5, 2);
                    this.hand.material.emissiveIntensity = 0.5;
                    
                    this.seqIndex++;
                    this.phase = 'wait';
                    this.phaseTimer = 0;
                }
            }

            this.updateMetrics();
            this.updateTimer();
        }


        updateMetrics() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('metric-1').textContent = this.correctPlacements + this.repeatRecognitions;
            document.getElementById('metric-2').textContent = this.memoryErrors + this.ruleErrors;
            const avgRT = this.reactionTimes.length > 0 ?
                Math.round(this.reactionTimes.reduce((a, b) => a + b, 0) / this.reactionTimes.length) : 0;
            document.getElementById('metric-3').textContent = avgRT + 'ms';
        }

        getResults() {
            const totalAttempts = this.correctPlacements + this.repeatRecognitions + this.memoryErrors + this.ruleErrors + this.missedBlocks;
            const accuracy = totalAttempts > 0 ? 
                ((this.correctPlacements + this.repeatRecognitions) / totalAttempts * 100) : 0;
            const avgRT = this.reactionTimes.length > 0 ?
                this.reactionTimes.reduce((a, b) => a + b, 0) / this.reactionTimes.length : 0;

            return {
                score: this.score,
                correctPlacements: this.correctPlacements,
                repeatRecognitions: this.repeatRecognitions,
                memoryErrors: this.memoryErrors,
                ruleErrors: this.ruleErrors,
                missedBlocks: this.missedBlocks,
                accuracy: accuracy.toFixed(1) + '%',
                avgReactionTime: avgRT.toFixed(0) + 'ms',
                totalBlocks: totalAttempts
            };
        }
    }

    // ============================================================================
    // MEMORY MATCH MODULE (Visual Memory)
    // ============================================================================

/* --- GAMIFIED: MemoryMatchModule (js/modules/gamified/memorymatch.js) --- */
    class MemoryMatchModule extends BaseModule {
        constructor(e) {
            super(e);
            this.cards = [];
            this.flippedCards = [];
            this.matchedPairs = 0;
            this.attempts = 0;
            this.correctMatches = 0;
            this.wrongMatches = 0;
            this.flipTimes = [];
            this.lastFlipTime = 0;
            this.canFlip = true;
            this.symbols = ['‚òÖ', '‚óè', '‚ñ≤', '‚ñ†', '‚óÜ', '‚ô•', '‚ô†', '‚ô£'];
            this.gridSize = 4; // 4x4 = 16 cards = 8 pairs
        }

        init() {
            this.engine.camera.position.set(0, 12, 8);
            this.engine.camera.lookAt(0, 0, 0);

            // Create table
            const table = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.3, 10),
                new THREE.MeshStandardMaterial({ color: 0x2a4a2a, roughness: 0.8 })
            );
            table.position.y = -0.15;
            this.addObject(table);

            // Create cards
            const cardPairs = [...this.symbols, ...this.symbols];
            this.shuffleArray(cardPairs);

            const spacing = 2.5;
            const startX = -((this.gridSize - 1) * spacing) / 2;
            const startZ = -((this.gridSize - 1) * spacing) / 2;

            for (let i = 0; i < 16; i++) {
                const row = Math.floor(i / this.gridSize);
                const col = i % this.gridSize;
                const card = this.createCard(cardPairs[i], i);
                card.position.set(startX + col * spacing, 0.2, startZ + row * spacing);
                this.cards.push(card);
                this.addObject(card);
            }

            // Hand cursor
            this.hand = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 })
            );
            this.hand.position.set(0, 1, 0);
            this.addObject(this.hand);

            // Instructions
            const instr = this.createTextSprite('MATCH THE PAIRS', 0.3, '#00d4ff');
            instr.position.set(0, 0.5, -6);
            this.addObject(instr);
        }

        createCard(symbol, index) {
            const group = new THREE.Group();
            
            // Card back (face down)
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 2),
                new THREE.MeshStandardMaterial({ color: 0x4444aa, emissive: 0x4444aa, emissiveIntensity: 0.2 })
            );
            group.add(back);

            // Card front (hidden initially)
            const front = new THREE.Mesh(
                new THREE.BoxGeometry(1.9, 0.12, 1.9),
                new THREE.MeshStandardMaterial({ color: 0xffffee, emissive: 0xffffee, emissiveIntensity: 0.1 })
            );
            front.position.y = 0.01;
            front.visible = false;
            group.add(front);

            // Symbol
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ff8844', '#8844ff'];
            const symSprite = this.createTextSprite(symbol, 0.8, colors[this.symbols.indexOf(symbol)]);
            symSprite.position.y = 0.2;
            symSprite.visible = false;
            group.add(symSprite);

            group.userData = { symbol, index, isFlipped: false, isMatched: false, back, front, symSprite };
            return group;
        }

        shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        flipCard(card, faceUp) {
            card.userData.isFlipped = faceUp;
            card.userData.back.visible = !faceUp;
            card.userData.front.visible = faceUp;
            card.userData.symSprite.visible = faceUp;
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            const lt = cd.left?.trackpad || { x: 127, y: 127 };
            const grip = cd.right?.gestures?.grip?.pull || cd.left?.gestures?.grip?.pull || 0;
            const isGripping = grip > 50;

            // Update hand position
            this.hand.position.x = ((lt.x - 127) / 127) * 5;
            this.hand.position.z = ((lt.y - 127) / 127) * 4;
            this.hand.material.emissiveIntensity = isGripping ? 1 : 0.5;

            // Check for card selection
            if (isGripping && !this.lastGrip && this.canFlip) {
                for (const card of this.cards) {
                    if (card.userData.isMatched || card.userData.isFlipped) continue;
                    const dist = Math.sqrt(
                        Math.pow(this.hand.position.x - card.position.x, 2) +
                        Math.pow(this.hand.position.z - card.position.z, 2)
                    );
                    if (dist < 1.2) {
                        this.selectCard(card);
                        break;
                    }
                }
            }
            this.lastGrip = isGripping;

            this.updateMetrics();
            this.updateTimer();

            if (this.matchedPairs >= 8) {
                showResults('memorymatch', this.getResults());
            }
        }

        selectCard(card) {
            const now = Date.now();
            if (this.lastFlipTime) this.flipTimes.push(now - this.lastFlipTime);
            this.lastFlipTime = now;

            this.flipCard(card, true);
            this.flippedCards.push(card);

            if (this.flippedCards.length === 2) {
                this.attempts++;
                this.canFlip = false;
                const [c1, c2] = this.flippedCards;

                if (c1.userData.symbol === c2.userData.symbol) {
                    // Match!
                    this.correctMatches++;
                    this.matchedPairs++;
                    c1.userData.isMatched = true;
                    c2.userData.isMatched = true;
                    this.createFeedback(c1.position, true, 'MATCH!');
                    this.flippedCards = [];
                    this.canFlip = true;
                } else {
                    // No match - flip back after delay
                    this.wrongMatches++;
                    this.createFeedback(c1.position, false, 'NO MATCH');
                    setTimeout(() => {
                        this.flipCard(c1, false);
                        this.flipCard(c2, false);
                        this.flippedCards = [];
                        this.canFlip = true;
                    }, 1000);
                }
            }
        }

        createFeedback(pos, success, text) {
            const sprite = this.createTextSprite(text, 0.35, success ? '#00ff88' : '#ff4444');
            sprite.position.set(pos.x, 2, pos.z);
            this.addObject(sprite);
            let life = 1;
            const fade = () => { life -= 0.03; if (life <= 0) { this.scene.remove(sprite); return; } sprite.position.y += 0.03; sprite.material.opacity = life; requestAnimationFrame(fade); };
            fade();
        }

        runDemo(dt) {
            this.demoTime += dt;
            
            if (!this.demoState) {
                this.demoState = 'init';
                this.demoCardQueue = [];
                this.demoTimer = 0;
            }

            this.demoTimer += dt;

            if (this.demoState === 'init' && this.demoTimer > 0.5) {
                // Find two matching unmatched cards
                const unmatched = this.cards.filter(c => !c.userData.isMatched && !c.userData.isFlipped);
                if (unmatched.length < 2) {
                    if (this.demoTimer > 2) stopAssessment();
                    return;
                }
                
                // Sometimes make a mistake (30%)
                if (Math.random() < 0.3 && unmatched.length >= 4) {
                    const c1 = unmatched[0];
                    const c2 = unmatched.find(c => c.userData.symbol !== c1.userData.symbol);
                    this.demoCardQueue = [c1, c2];
                } else {
                    const c1 = unmatched[0];
                    const c2 = unmatched.find(c => c !== c1 && c.userData.symbol === c1.userData.symbol);
                    this.demoCardQueue = [c1, c2];
                }
                this.demoState = 'move1';
                this.demoTimer = 0;
            }

            if (this.demoState === 'move1' && this.demoCardQueue[0]) {
                const target = this.demoCardQueue[0];
                this.hand.position.x += (target.position.x - this.hand.position.x) * 0.1;
                this.hand.position.z += (target.position.z - this.hand.position.z) * 0.1;
                
                if (this.demoTimer > 0.8) {
                    this.selectCard(target);
                    this.demoState = 'move2';
                    this.demoTimer = 0;
                }
            }

            if (this.demoState === 'move2' && this.demoCardQueue[1]) {
                const target = this.demoCardQueue[1];
                this.hand.position.x += (target.position.x - this.hand.position.x) * 0.1;
                this.hand.position.z += (target.position.z - this.hand.position.z) * 0.1;
                
                if (this.demoTimer > 0.8) {
                    this.selectCard(target);
                    this.demoState = 'wait';
                    this.demoTimer = 0;
                }
            }

            if (this.demoState === 'wait' && this.demoTimer > 1.5) {
                this.demoState = 'init';
                this.demoTimer = 0;
            }

            this.updateMetrics();
            this.updateTimer();
        }

        updateMetrics() {
            document.getElementById('score').textContent = this.matchedPairs;
            document.getElementById('metric-1').textContent = this.attempts;
            document.getElementById('metric-2').textContent = this.correctMatches;
            const avgTime = this.flipTimes.length > 0 ? Math.round(this.flipTimes.reduce((a,b)=>a+b,0)/this.flipTimes.length) : 0;
            document.getElementById('metric-3').textContent = avgTime + 'ms';
        }

        getResults() {
            const accuracy = this.attempts > 0 ? (this.correctMatches / this.attempts * 100) : 0;
            const avgTime = this.flipTimes.length > 0 ? this.flipTimes.reduce((a,b)=>a+b,0)/this.flipTimes.length : 0;
            return {
                matchedPairs: this.matchedPairs,
                attempts: this.attempts,
                accuracy: accuracy.toFixed(1) + '%',
                avgFlipTime: avgTime.toFixed(0) + 'ms',
                correctMatches: this.correctMatches,
                wrongMatches: this.wrongMatches
            };
        }
    }

    // ============================================================================
    // TOWER STACK MODULE (Motor Control + Planning)
    // ============================================================================

/* --- GAMIFIED: TowerStackModule (js/modules/gamified/towerstack.js) --- */
    class TowerStackModule extends BaseModule {
        constructor(e) {
            super(e);
            this.blocks = [];
            this.currentBlock = null;
            this.towerHeight = 0;
            this.maxHeight = 0;
            this.blocksPlaced = 0;
            this.blocksFallen = 0;
            this.placementAccuracy = [];
            this.swingSpeed = 2;
            this.swingAngle = 0;
            this.blockWidth = 2;
        }

        init() {
            this.engine.camera.position.set(0, 8, 15);
            this.engine.camera.lookAt(0, 5, 0);

            // Platform
            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.5, 6),
                new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 })
            );
            platform.position.y = 0.25;
            this.addObject(platform);

            // Base block
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(this.blockWidth, 0.5, 2),
                new THREE.MeshStandardMaterial({ color: 0x888888 })
            );
            base.position.y = 0.75;
            base.userData = { width: this.blockWidth, placed: true };
            this.blocks.push(base);
            this.addObject(base);
            this.towerHeight = 1;

            // Spawn first moving block
            this.spawnBlock();

            // Instructions
            const instr = this.createTextSprite('STACK THE BLOCKS!', 0.3, '#00d4ff');
            instr.position.set(0, 12, 0);
            this.addObject(instr);

            // Height indicator
            this.heightLabel = this.createTextSprite('HEIGHT: 1', 0.25, '#ffaa00');
            this.heightLabel.position.set(-5, 8, 0);
            this.addObject(this.heightLabel);
        }

        spawnBlock() {
            const lastBlock = this.blocks[this.blocks.length - 1];
            const newWidth = Math.max(0.5, lastBlock.userData.width);
            
            const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xff8844];
            const color = colors[this.blocksPlaced % colors.length];

            const block = new THREE.Mesh(
                new THREE.BoxGeometry(newWidth, 0.5, 2),
                new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 })
            );
            block.position.y = this.towerHeight + 0.25 + 3;
            block.userData = { width: newWidth, placed: false };
            this.currentBlock = block;
            this.swingAngle = 0;
            this.addObject(block);
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            const grip = cd.right?.gestures?.grip?.pull || cd.left?.gestures?.grip?.pull || 0;
            const isGripping = grip > 50;

            // Swing current block
            if (this.currentBlock && !this.currentBlock.userData.placed) {
                this.swingAngle += this.swingSpeed * dt;
                this.currentBlock.position.x = Math.sin(this.swingAngle) * 5;
            }

            // Drop on grip
            if (isGripping && !this.lastGrip && this.currentBlock) {
                this.dropBlock();
            }
            this.lastGrip = isGripping;

            this.updateMetrics();
            this.updateTimer();

            if (this.blocksPlaced >= 10 || this.blocksFallen >= 3) {
                showResults('towerstack', this.getResults());
            }
        }

        dropBlock() {
            if (!this.currentBlock) return;
            
            const lastBlock = this.blocks[this.blocks.length - 1];
            const currentX = this.currentBlock.position.x;
            const lastX = lastBlock.position.x;
            const overlap = this.calculateOverlap(currentX, this.currentBlock.userData.width, lastX, lastBlock.userData.width);

            if (overlap <= 0) {
                // Missed completely
                this.blocksFallen++;
                this.animateFall(this.currentBlock);
                this.createFeedback(this.currentBlock.position, false, 'MISS!');
                this.currentBlock = null;
                setTimeout(() => this.spawnBlock(), 500);
            } else {
                // Calculate accuracy
                const perfectOverlap = Math.min(this.currentBlock.userData.width, lastBlock.userData.width);
                const accuracy = (overlap / perfectOverlap) * 100;
                this.placementAccuracy.push(accuracy);

                // Trim block if partial overlap
                if (overlap < this.currentBlock.userData.width) {
                    this.trimBlock(this.currentBlock, overlap, currentX, lastX);
                }

                // Place block
                this.currentBlock.position.y = this.towerHeight + 0.25;
                this.currentBlock.userData.placed = true;
                this.blocks.push(this.currentBlock);
                this.blocksPlaced++;
                this.towerHeight += 0.5;
                this.maxHeight = Math.max(this.maxHeight, this.towerHeight);

                const msg = accuracy > 90 ? 'PERFECT!' : accuracy > 70 ? 'GOOD!' : 'OK';
                this.createFeedback(this.currentBlock.position, true, msg);

                // Update camera
                if (this.towerHeight > 5) {
                    this.engine.camera.position.y = this.towerHeight + 3;
                    this.engine.camera.lookAt(0, this.towerHeight, 0);
                }

                // Speed up
                this.swingSpeed = Math.min(5, this.swingSpeed + 0.15);

                this.currentBlock = null;
                setTimeout(() => this.spawnBlock(), 300);
            }
        }

        calculateOverlap(x1, w1, x2, w2) {
            const left1 = x1 - w1/2, right1 = x1 + w1/2;
            const left2 = x2 - w2/2, right2 = x2 + w2/2;
            return Math.max(0, Math.min(right1, right2) - Math.max(left1, left2));
        }

        trimBlock(block, newWidth, currentX, lastX) {
            const offset = (currentX > lastX) ? (block.userData.width - newWidth) / 2 : -(block.userData.width - newWidth) / 2;
            block.scale.x = newWidth / block.userData.width;
            block.position.x = currentX - offset;
            block.userData.width = newWidth;
        }

        animateFall(block) {
            let vy = 0;
            const fall = () => {
                vy -= 0.02;
                block.position.y += vy;
                block.rotation.z += 0.05;
                if (block.position.y < -5) { this.scene.remove(block); return; }
                requestAnimationFrame(fall);
            };
            fall();
        }

        createFeedback(pos, success, text) {
            const sprite = this.createTextSprite(text, 0.4, success ? '#00ff88' : '#ff4444');
            sprite.position.copy(pos);
            sprite.position.y += 1;
            this.addObject(sprite);
            let life = 1;
            const fade = () => { life -= 0.02; if (life <= 0) { this.scene.remove(sprite); return; } sprite.position.y += 0.05; sprite.material.opacity = life; requestAnimationFrame(fade); };
            fade();
        }

        runDemo(dt) {
            this.demoTime += dt;

            if (this.currentBlock && !this.currentBlock.userData.placed) {
                this.swingAngle += this.swingSpeed * dt;
                this.currentBlock.position.x = Math.sin(this.swingAngle) * 5;

                // Drop when roughly aligned (with some variation)
                const lastBlock = this.blocks[this.blocks.length - 1];
                const diff = Math.abs(this.currentBlock.position.x - lastBlock.position.x);
                const threshold = 0.3 + Math.random() * 0.5;
                
                if (diff < threshold && Math.abs(Math.cos(this.swingAngle)) > 0.8) {
                    this.dropBlock();
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.blocksPlaced >= 8 || this.demoTime > 25) stopAssessment();
        }

        updateMetrics() {
            document.getElementById('score').textContent = this.blocksPlaced;
            document.getElementById('metric-1').textContent = this.maxHeight.toFixed(1);
            const avgAcc = this.placementAccuracy.length > 0 ? this.placementAccuracy.reduce((a,b)=>a+b,0)/this.placementAccuracy.length : 0;
            document.getElementById('metric-2').textContent = avgAcc.toFixed(0) + '%';
            document.getElementById('metric-3').textContent = this.blocksFallen;
        }

        getResults() {
            const avgAcc = this.placementAccuracy.length > 0 ? this.placementAccuracy.reduce((a,b)=>a+b,0)/this.placementAccuracy.length : 0;
            return {
                blocksPlaced: this.blocksPlaced,
                maxHeight: this.maxHeight.toFixed(1),
                avgAccuracy: avgAcc.toFixed(1) + '%',
                blocksFallen: this.blocksFallen,
                swingSpeed: this.swingSpeed.toFixed(1)
            };
        }
    }

    // ============================================================================
    // PATTERN RUNNER MODULE (Procedural Memory)
    // ============================================================================

/* --- GAMIFIED: PatternRunnerModule (js/modules/gamified/patternrunner.js) --- */
    class PatternRunnerModule extends BaseModule {
        constructor(e) {
            super(e);
            this.path = [];
            this.playerPos = { x: 0, z: 0 };
            this.currentTarget = 0;
            this.score = 0;
            this.errors = 0;
            this.sequenceLength = 4;
            this.showingPattern = true;
            this.patternIndex = 0;
            this.reactionTimes = [];
            this.lastTargetTime = 0;
        }

        init() {
            this.engine.camera.position.set(0, 15, 10);
            this.engine.camera.lookAt(0, 0, 0);

            // Create grid
            const gridSize = 3;
            this.tiles = [];
            const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xff8844, 0x88ff44, 0x4488ff];
            
            for (let z = -1; z <= 1; z++) {
                for (let x = -1; x <= 1; x++) {
                    const idx = (z + 1) * 3 + (x + 1);
                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.3, 3),
                        new THREE.MeshStandardMaterial({ color: colors[idx], emissive: colors[idx], emissiveIntensity: 0.1 })
                    );
                    tile.position.set(x * 3.5, 0.15, z * 3.5);
                    tile.userData = { gridX: x, gridZ: z, baseColor: colors[idx], index: idx };
                    this.tiles.push(tile);
                    this.addObject(tile);
                }
            }

            // Player marker
            this.player = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8 })
            );
            this.player.position.set(0, 1, 0);
            this.addObject(this.player);

            // Generate pattern
            this.generatePattern();

            // Instructions
            this.statusLabel = this.createTextSprite('WATCH THE PATTERN...', 0.35, '#00d4ff');
            this.statusLabel.position.set(0, 8, 0);
            this.addObject(this.statusLabel);
        }

        generatePattern() {
            this.path = [];
            const used = new Set();
            for (let i = 0; i < this.sequenceLength; i++) {
                let idx;
                do { idx = Math.floor(Math.random() * 9); } while (used.has(idx) && used.size < 9);
                used.add(idx);
                this.path.push(idx);
            }
            this.showingPattern = true;
            this.patternIndex = 0;
            this.patternTimer = 0;
        }

        highlightTile(idx, on) {
            const tile = this.tiles[idx];
            tile.material.emissiveIntensity = on ? 0.8 : 0.1;
            tile.position.y = on ? 0.4 : 0.15;
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            // Pattern display phase
            if (this.showingPattern) {
                this.patternTimer += dt;
                const showTime = 0.8;
                const idx = Math.floor(this.patternTimer / showTime);
                
                // Reset all tiles
                this.tiles.forEach((t, i) => this.highlightTile(i, false));
                
                if (idx < this.path.length) {
                    this.highlightTile(this.path[idx], true);
                } else if (this.patternTimer > this.path.length * showTime + 0.5) {
                    this.showingPattern = false;
                    this.currentTarget = 0;
                    this.scene.remove(this.statusLabel);
                    this.statusLabel = this.createTextSprite('YOUR TURN!', 0.35, '#00ff88');
                    this.statusLabel.position.set(0, 8, 0);
                    this.addObject(this.statusLabel);
                    this.lastTargetTime = Date.now();
                }
            } else {
                // Player input phase
                const lt = cd.left?.trackpad || { x: 127, y: 127 };
                const grip = cd.right?.gestures?.grip?.pull || cd.left?.gestures?.grip?.pull || 0;

                // Move player
                const targetX = ((lt.x - 127) / 127) * 3.5;
                const targetZ = ((lt.y - 127) / 127) * 3.5;
                this.player.position.x += (targetX - this.player.position.x) * 0.15;
                this.player.position.z += (targetZ - this.player.position.z) * 0.15;

                // Check tile selection on grip
                if (grip > 50 && !this.lastGrip) {
                    const selectedTile = this.tiles.find(t => 
                        Math.abs(this.player.position.x - t.position.x) < 1.5 &&
                        Math.abs(this.player.position.z - t.position.z) < 1.5
                    );

                    if (selectedTile) {
                        const rt = Date.now() - this.lastTargetTime;
                        this.reactionTimes.push(rt);
                        this.lastTargetTime = Date.now();

                        if (selectedTile.userData.index === this.path[this.currentTarget]) {
                            // Correct!
                            this.score += 10;
                            this.highlightTile(selectedTile.userData.index, true);
                            setTimeout(() => this.highlightTile(selectedTile.userData.index, false), 200);
                            this.currentTarget++;

                            if (this.currentTarget >= this.path.length) {
                                // Pattern complete - next round
                                this.sequenceLength = Math.min(9, this.sequenceLength + 1);
                                setTimeout(() => {
                                    this.generatePattern();
                                    this.scene.remove(this.statusLabel);
                                    this.statusLabel = this.createTextSprite('WATCH THE PATTERN...', 0.35, '#00d4ff');
                                    this.statusLabel.position.set(0, 8, 0);
                                    this.addObject(this.statusLabel);
                                }, 500);
                            }
                        } else {
                            // Wrong!
                            this.errors++;
                            this.createFeedback(selectedTile.position, false, 'WRONG!');
                        }
                    }
                }
                this.lastGrip = grip > 50;
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.errors >= 3 || this.sequenceLength > 8) {
                showResults('patternrunner', this.getResults());
            }
        }

        createFeedback(pos, success, text) {
            const sprite = this.createTextSprite(text, 0.4, success ? '#00ff88' : '#ff4444');
            sprite.position.set(pos.x, 3, pos.z);
            this.addObject(sprite);
            let life = 1;
            const fade = () => { life -= 0.03; if (life <= 0) { this.scene.remove(sprite); return; } sprite.position.y += 0.03; sprite.material.opacity = life; requestAnimationFrame(fade); };
            fade();
        }

        runDemo(dt) {
            this.demoTime += dt;

            if (this.showingPattern) {
                this.patternTimer += dt;
                const showTime = 0.6;
                const idx = Math.floor(this.patternTimer / showTime);
                
                this.tiles.forEach((t, i) => this.highlightTile(i, false));
                
                if (idx < this.path.length) {
                    this.highlightTile(this.path[idx], true);
                } else if (this.patternTimer > this.path.length * showTime + 0.3) {
                    this.showingPattern = false;
                    this.currentTarget = 0;
                    this.demoInputTimer = 0;
                }
            } else {
                this.demoInputTimer = (this.demoInputTimer || 0) + dt;
                
                // Move player to current target
                const targetTile = this.tiles[this.path[this.currentTarget]];
                if (targetTile) {
                    this.player.position.x += (targetTile.position.x - this.player.position.x) * 0.1;
                    this.player.position.z += (targetTile.position.z - this.player.position.z) * 0.1;

                    if (this.demoInputTimer > 0.6) {
                        this.score += 10;
                        this.highlightTile(this.path[this.currentTarget], true);
                        setTimeout(() => this.highlightTile(this.path[this.currentTarget], false), 200);
                        this.currentTarget++;
                        this.demoInputTimer = 0;

                        if (this.currentTarget >= this.path.length) {
                            this.sequenceLength = Math.min(7, this.sequenceLength + 1);
                            setTimeout(() => this.generatePattern(), 500);
                        }
                    }
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.demoTime > 25) stopAssessment();
        }

        updateMetrics() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('metric-1').textContent = this.sequenceLength;
            document.getElementById('metric-2').textContent = this.errors;
            const avgRT = this.reactionTimes.length > 0 ? Math.round(this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length) : 0;
            document.getElementById('metric-3').textContent = avgRT + 'ms';
        }

        getResults() {
            const avgRT = this.reactionTimes.length > 0 ? this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length : 0;
            return {
                score: this.score,
                maxSequence: this.sequenceLength,
                errors: this.errors,
                avgReactionTime: avgRT.toFixed(0) + 'ms'
            };
        }
    }

    // ============================================================================
    // WHACK-A-MOLE MODULE (Attention + Reaction Time)
    // ============================================================================

/* --- GAMIFIED: WhackAMoleModule (js/modules/gamified/whackamole.js) --- */
    class WhackAMoleModule extends BaseModule {
        constructor(e) {
            super(e);
            this.holes = [];
            this.moles = [];
            this.score = 0;
            this.hits = 0;
            this.misses = 0;
            this.reactionTimes = [];
            this.spawnTimer = 0;
            this.spawnInterval = 1.5;
            this.moleLifetime = 1.2;
        }

        init() {
            this.engine.camera.position.set(0, 12, 10);
            this.engine.camera.lookAt(0, 0, 0);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(16, 12),
                new THREE.MeshStandardMaterial({ color: 0x3d6b3d, roughness: 0.9 })
            );
            ground.rotation.x = -Math.PI / 2;
            this.addObject(ground);

            // Create holes in 3x3 grid
            for (let z = -1; z <= 1; z++) {
                for (let x = -1; x <= 1; x++) {
                    const hole = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1, 0.3, 32),
                        new THREE.MeshStandardMaterial({ color: 0x2a1810 })
                    );
                    hole.position.set(x * 4, 0.15, z * 3);
                    hole.userData = { gridX: x, gridZ: z, hasMole: false };
                    this.holes.push(hole);
                    this.addObject(hole);

                    // Hole rim
                    const rim = new THREE.Mesh(
                        new THREE.TorusGeometry(1, 0.15, 8, 32),
                        new THREE.MeshStandardMaterial({ color: 0x4a3020 })
                    );
                    rim.rotation.x = -Math.PI / 2;
                    rim.position.set(x * 4, 0.3, z * 3);
                    this.addObject(rim);
                }
            }

            // Hammer (cursor)
            this.hammer = new THREE.Group();
            const hammerHead = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.8, 1),
                new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
            );
            hammerHead.position.y = 0.4;
            this.hammer.add(hammerHead);
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 2),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            handle.position.y = -0.6;
            this.hammer.add(handle);
            this.hammer.position.set(0, 3, 0);
            this.addObject(this.hammer);

            // Instructions
            const instr = this.createTextSprite('WHACK THE MOLES!', 0.3, '#00d4ff');
            instr.position.set(0, 6, -5);
            this.addObject(instr);
        }

        spawnMole() {
            const availableHoles = this.holes.filter(h => !h.userData.hasMole);
            if (availableHoles.length === 0) return;

            const hole = availableHoles[Math.floor(Math.random() * availableHoles.length)];
            hole.userData.hasMole = true;

            // Create mole
            const mole = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            mole.add(body);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.25, 0.2, 0.5);
            mole.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.25, 0.2, 0.5);
            mole.add(rightEye);

            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xff6666 })
            );
            nose.position.set(0, 0, 0.65);
            mole.add(nose);

            mole.position.set(hole.position.x, -0.5, hole.position.z);
            mole.userData = { hole, spawnTime: Date.now(), rising: true, targetY: 0.8, active: true };
            this.moles.push(mole);
            this.addObject(mole);
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            const lt = cd.left?.trackpad || { x: 127, y: 127 };
            const grip = cd.right?.gestures?.grip?.pull || cd.left?.gestures?.grip?.pull || 0;
            const isGripping = grip > 50;

            // Update hammer position
            this.hammer.position.x = ((lt.x - 127) / 127) * 6;
            this.hammer.position.z = ((lt.y - 127) / 127) * 4;
            
            // Hammer swing animation
            if (isGripping && !this.lastGrip) {
                this.hammer.rotation.x = -0.5;
                this.hammer.position.y = 1;
                this.checkHit();
            } else {
                this.hammer.rotation.x += (0 - this.hammer.rotation.x) * 0.2;
                this.hammer.position.y += (3 - this.hammer.position.y) * 0.1;
            }
            this.lastGrip = isGripping;

            // Spawn moles
            this.spawnTimer += dt;
            if (this.spawnTimer >= this.spawnInterval) {
                this.spawnMole();
                this.spawnTimer = 0;
                this.spawnInterval = Math.max(0.8, this.spawnInterval - 0.05);
            }

            // Update moles
            for (let i = this.moles.length - 1; i >= 0; i--) {
                const mole = this.moles[i];
                
                if (mole.userData.rising) {
                    mole.position.y += (mole.userData.targetY - mole.position.y) * 0.15;
                    if (mole.position.y > mole.userData.targetY - 0.1) {
                        mole.userData.rising = false;
                    }
                }

                // Check lifetime
                const age = Date.now() - mole.userData.spawnTime;
                if (age > this.moleLifetime * 1000 && mole.userData.active) {
                    mole.userData.active = false;
                    this.misses++;
                    this.retreatMole(mole, i);
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.hits + this.misses >= 20) {
                showResults('whackamole', this.getResults());
            }
        }

        checkHit() {
            for (let i = this.moles.length - 1; i >= 0; i--) {
                const mole = this.moles[i];
                if (!mole.userData.active) continue;
                
                const dist = Math.sqrt(
                    Math.pow(this.hammer.position.x - mole.position.x, 2) +
                    Math.pow(this.hammer.position.z - mole.position.z, 2)
                );

                if (dist < 1.5 && mole.position.y > 0) {
                    // Hit!
                    const rt = Date.now() - mole.userData.spawnTime;
                    this.reactionTimes.push(rt);
                    this.hits++;
                    this.score += Math.max(10, 50 - Math.floor(rt / 20));
                    mole.userData.active = false;
                    this.createFeedback(mole.position, true, '+' + Math.max(10, 50 - Math.floor(rt / 20)));
                    this.retreatMole(mole, i);
                    return;
                }
            }
        }

        retreatMole(mole, index) {
            mole.userData.hole.userData.hasMole = false;
            const retreat = () => {
                mole.position.y -= 0.15;
                if (mole.position.y < -1) {
                    this.scene.remove(mole);
                    this.moles.splice(this.moles.indexOf(mole), 1);
                    return;
                }
                requestAnimationFrame(retreat);
            };
            retreat();
        }

        createFeedback(pos, success, text) {
            const sprite = this.createTextSprite(text, 0.4, success ? '#00ff88' : '#ff4444');
            sprite.position.set(pos.x, 2, pos.z);
            this.addObject(sprite);
            let life = 1;
            const fade = () => { life -= 0.03; if (life <= 0) { this.scene.remove(sprite); return; } sprite.position.y += 0.04; sprite.material.opacity = life; requestAnimationFrame(fade); };
            fade();
        }

        runDemo(dt) {
            this.demoTime += dt;

            // Spawn moles
            this.spawnTimer += dt;
            if (this.spawnTimer >= this.spawnInterval) {
                this.spawnMole();
                this.spawnTimer = 0;
            }

            // Find active mole and move hammer toward it
            const activeMole = this.moles.find(m => m.userData.active && m.position.y > 0.3);
            if (activeMole) {
                this.hammer.position.x += (activeMole.position.x - this.hammer.position.x) * 0.15;
                this.hammer.position.z += (activeMole.position.z - this.hammer.position.z) * 0.15;

                const dist = Math.sqrt(
                    Math.pow(this.hammer.position.x - activeMole.position.x, 2) +
                    Math.pow(this.hammer.position.z - activeMole.position.z, 2)
                );

                if (dist < 0.5) {
                    // Swing!
                    this.hammer.rotation.x = -0.5;
                    this.hammer.position.y = 1;
                    
                    const rt = Date.now() - activeMole.userData.spawnTime;
                    this.reactionTimes.push(rt);
                    this.hits++;
                    this.score += Math.max(10, 50 - Math.floor(rt / 20));
                    activeMole.userData.active = false;
                    this.createFeedback(activeMole.position, true, '+' + Math.max(10, 50 - Math.floor(rt / 20)));
                    this.retreatMole(activeMole, this.moles.indexOf(activeMole));
                }
            } else {
                this.hammer.rotation.x += (0 - this.hammer.rotation.x) * 0.1;
                this.hammer.position.y += (3 - this.hammer.position.y) * 0.1;
            }

            // Update moles
            for (let i = this.moles.length - 1; i >= 0; i--) {
                const mole = this.moles[i];
                if (mole.userData.rising) {
                    mole.position.y += (mole.userData.targetY - mole.position.y) * 0.15;
                    if (mole.position.y > mole.userData.targetY - 0.1) mole.userData.rising = false;
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.hits >= 15 || this.demoTime > 25) stopAssessment();
        }

        updateMetrics() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('metric-1').textContent = this.hits;
            document.getElementById('metric-2').textContent = this.misses;
            const avgRT = this.reactionTimes.length > 0 ? Math.round(this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length) : 0;
            document.getElementById('metric-3').textContent = avgRT + 'ms';
        }

        getResults() {
            const accuracy = (this.hits + this.misses) > 0 ? (this.hits / (this.hits + this.misses) * 100) : 0;
            const avgRT = this.reactionTimes.length > 0 ? this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length : 0;
            return {
                score: this.score,
                hits: this.hits,
                misses: this.misses,
                accuracy: accuracy.toFixed(1) + '%',
                avgReactionTime: avgRT.toFixed(0) + 'ms'
            };
        }
    }

    // ============================================================================
    // BALANCE BOARD MODULE (Postural Control)
    // ============================================================================

/* --- GAMIFIED: BalanceBoardModule (js/modules/gamified/balanceboard.js) --- */
    class BalanceBoardModule extends BaseModule {
        constructor(e) {
            super(e);
            this.boardTilt = { x: 0, z: 0 };
            this.ballPos = { x: 0, z: 0 };
            this.ballVel = { x: 0, z: 0 };
            this.targets = [];
            this.currentTarget = 0;
            this.score = 0;
            this.targetsHit = 0;
            this.fallOffs = 0;
            this.timeInTarget = 0;
            this.stabilityScores = [];
        }

        init() {
            this.engine.camera.position.set(0, 12, 8);
            this.engine.camera.lookAt(0, 0, 0);

            // Balance board
            this.board = new THREE.Mesh(
                new THREE.BoxGeometry(8, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 })
            );
            this.board.position.y = 2;
            this.addObject(this.board);

            // Board edge markers
            const edgeMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.3 });
            [[-4, 0], [4, 0], [0, -4], [0, 4]].forEach(([x, z]) => {
                const edge = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, x === 0 ? 8 : 0.3), edgeMat);
                edge.position.set(x, 0.17, z);
                this.board.add(edge);
            });

            // Ball
            this.ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x4488ff, emissiveIntensity: 0.5, metalness: 0.8 })
            );
            this.ball.position.set(0, 2.5, 0);
            this.addObject(this.ball);

            // Create targets
            this.createTargets();

            // Pivot point visualization
            const pivot = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            pivot.position.y = 1.7;
            this.addObject(pivot);

            // Instructions
            const instr = this.createTextSprite('TILT TO GUIDE BALL TO TARGETS', 0.25, '#00d4ff');
            instr.position.set(0, 6, 0);
            this.addObject(instr);
        }

        createTargets() {
            const positions = [
                { x: 2, z: 2 }, { x: -2, z: 2 }, { x: -2, z: -2 }, { x: 2, z: -2 },
                { x: 0, z: 3 }, { x: 3, z: 0 }, { x: 0, z: -3 }, { x: -3, z: 0 }
            ];

            positions.forEach((pos, i) => {
                const target = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.6, 0.1, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ff88, 
                        emissive: 0x00ff88, 
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                target.position.set(pos.x, 0.2, pos.z);
                target.userData = { index: i, active: i === 0 };
                if (i !== 0) target.visible = false;
                this.board.add(target);
                this.targets.push(target);
            });
        }

        update(dt, cd) {
            if (this.isDemo) { this.runDemo(dt); return; }
            if (!this.isRunning) return;

            // Get tilt from controller
            const lt = cd.left?.trackpad || { x: 127, y: 127 };
            const targetTiltX = ((lt.y - 127) / 127) * 0.2;
            const targetTiltZ = ((lt.x - 127) / 127) * 0.2;

            // Smooth tilt
            this.boardTilt.x += (targetTiltX - this.boardTilt.x) * 0.1;
            this.boardTilt.z += (targetTiltZ - this.boardTilt.z) * 0.1;

            // Apply tilt to board
            this.board.rotation.x = this.boardTilt.x;
            this.board.rotation.z = this.boardTilt.z;

            // Ball physics
            const gravity = 15;
            this.ballVel.x += Math.sin(this.boardTilt.z) * gravity * dt;
            this.ballVel.z -= Math.sin(this.boardTilt.x) * gravity * dt;

            // Friction
            this.ballVel.x *= 0.98;
            this.ballVel.z *= 0.98;

            // Update ball position
            this.ballPos.x += this.ballVel.x * dt;
            this.ballPos.z += this.ballVel.z * dt;

            // Check bounds
            const maxPos = 3.5;
            if (Math.abs(this.ballPos.x) > maxPos || Math.abs(this.ballPos.z) > maxPos) {
                this.fallOffs++;
                this.ballPos = { x: 0, z: 0 };
                this.ballVel = { x: 0, z: 0 };
                this.createFeedback(this.ball.position, false, 'FALL!');
            }

            // Update ball visual position (on tilted board)
            this.ball.position.x = this.ballPos.x;
            this.ball.position.z = this.ballPos.z;
            this.ball.position.y = 2.5 + this.ballPos.x * Math.sin(this.boardTilt.z) - this.ballPos.z * Math.sin(this.boardTilt.x);

            // Check target collision
            const currentTarget = this.targets[this.currentTarget];
            if (currentTarget) {
                const dist = Math.sqrt(
                    Math.pow(this.ballPos.x - currentTarget.position.x, 2) +
                    Math.pow(this.ballPos.z - currentTarget.position.z, 2)
                );

                if (dist < 0.8) {
                    this.timeInTarget += dt;
                    currentTarget.material.emissiveIntensity = 0.8;

                    if (this.timeInTarget > 0.5) {
                        // Target hit!
                        this.targetsHit++;
                        this.score += 100;
                        
                        // Calculate stability (lower velocity = more stable)
                        const stability = Math.max(0, 100 - Math.sqrt(this.ballVel.x*this.ballVel.x + this.ballVel.z*this.ballVel.z) * 50);
                        this.stabilityScores.push(stability);

                        this.createFeedback(this.ball.position, true, '+100');
                        currentTarget.visible = false;
                        
                        this.currentTarget++;
                        this.timeInTarget = 0;
                        
                        if (this.currentTarget < this.targets.length) {
                            this.targets[this.currentTarget].visible = true;
                        }
                    }
                } else {
                    this.timeInTarget = 0;
                    currentTarget.material.emissiveIntensity = 0.3;
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.currentTarget >= this.targets.length || this.fallOffs >= 5) {
                showResults('balanceboard', this.getResults());
            }
        }

        createFeedback(pos, success, text) {
            const sprite = this.createTextSprite(text, 0.4, success ? '#00ff88' : '#ff4444');
            sprite.position.copy(pos);
            sprite.position.y += 1;
            this.addObject(sprite);
            let life = 1;
            const fade = () => { life -= 0.03; if (life <= 0) { this.scene.remove(sprite); return; } sprite.position.y += 0.03; sprite.material.opacity = life; requestAnimationFrame(fade); };
            fade();
        }

        runDemo(dt) {
            this.demoTime += dt;

            // Auto-tilt toward current target
            const currentTarget = this.targets[this.currentTarget];
            if (currentTarget && currentTarget.visible) {
                const dx = currentTarget.position.x - this.ballPos.x;
                const dz = currentTarget.position.z - this.ballPos.z;
                
                this.boardTilt.z += (dx * 0.03 - this.boardTilt.z) * 0.05;
                this.boardTilt.x += (-dz * 0.03 - this.boardTilt.x) * 0.05;
            }

            // Apply tilt
            this.board.rotation.x = this.boardTilt.x;
            this.board.rotation.z = this.boardTilt.z;

            // Ball physics
            const gravity = 15;
            this.ballVel.x += Math.sin(this.boardTilt.z) * gravity * dt;
            this.ballVel.z -= Math.sin(this.boardTilt.x) * gravity * dt;
            this.ballVel.x *= 0.98;
            this.ballVel.z *= 0.98;
            this.ballPos.x += this.ballVel.x * dt;
            this.ballPos.z += this.ballVel.z * dt;

            // Bounds check
            const maxPos = 3.5;
            if (Math.abs(this.ballPos.x) > maxPos) { this.ballPos.x = Math.sign(this.ballPos.x) * maxPos; this.ballVel.x *= -0.5; }
            if (Math.abs(this.ballPos.z) > maxPos) { this.ballPos.z = Math.sign(this.ballPos.z) * maxPos; this.ballVel.z *= -0.5; }

            // Update ball
            this.ball.position.x = this.ballPos.x;
            this.ball.position.z = this.ballPos.z;
            this.ball.position.y = 2.5 + this.ballPos.x * Math.sin(this.boardTilt.z) - this.ballPos.z * Math.sin(this.boardTilt.x);

            // Target collision
            if (currentTarget) {
                const dist = Math.sqrt(
                    Math.pow(this.ballPos.x - currentTarget.position.x, 2) +
                    Math.pow(this.ballPos.z - currentTarget.position.z, 2)
                );

                if (dist < 0.8) {
                    this.timeInTarget += dt;
                    currentTarget.material.emissiveIntensity = 0.8;

                    if (this.timeInTarget > 0.5) {
                        this.targetsHit++;
                        this.score += 100;
                        this.stabilityScores.push(80 + Math.random() * 20);
                        this.createFeedback(this.ball.position, true, '+100');
                        currentTarget.visible = false;
                        this.currentTarget++;
                        this.timeInTarget = 0;
                        if (this.currentTarget < this.targets.length) {
                            this.targets[this.currentTarget].visible = true;
                        }
                    }
                } else {
                    this.timeInTarget = 0;
                    currentTarget.material.emissiveIntensity = 0.3;
                }
            }

            this.updateMetrics();
            this.updateTimer();

            if (this.currentTarget >= 6 || this.demoTime > 30) stopAssessment();
        }

        updateMetrics() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('metric-1').textContent = this.targetsHit;
            document.getElementById('metric-2').textContent = this.fallOffs;
            const avgStab = this.stabilityScores.length > 0 ? Math.round(this.stabilityScores.reduce((a,b)=>a+b,0)/this.stabilityScores.length) : 0;
            document.getElementById('metric-3').textContent = avgStab + '%';
        }

        getResults() {
            const avgStab = this.stabilityScores.length > 0 ? this.stabilityScores.reduce((a,b)=>a+b,0)/this.stabilityScores.length : 0;
            return {
                score: this.score,
                targetsHit: this.targetsHit,
                fallOffs: this.fallOffs,
                avgStability: avgStab.toFixed(1) + '%'
            };
        }
    }

    // ============================================================================
    // PURDUE PEGBOARD MODULE (Bimanual)
    // ============================================================================

/* --- MOTOR: PurdueModule (js/modules/motor/purdue.js) --- */
    class PurdueModule extends BaseModule {
        constructor(e) { super(e); this.leftPegs = []; this.rightPegs = []; this.leftHoles = []; this.rightHoles = []; this.heldLeft = null; this.heldRight = null; 
            this.completedPairs = 0; this.leftCount = 0; this.rightCount = 0; this.lastLeftGrip = false; this.lastRightGrip = false; }
        init() { this.engine.camera.position.set(0,12,8); this.engine.camera.lookAt(0,0,0);
            const board = new THREE.Mesh(new THREE.BoxGeometry(10,0.3,4), new THREE.MeshStandardMaterial({color:0x2a2a35})); board.position.set(0,0.15,0); this.addObject(board);
            const divider = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.5,4), this.createGlowMaterial(0x00d4ff,0.3)); divider.position.set(0,0.4,0); this.addObject(divider);
            const ll = this.createTextSprite('LEFT', 0.4, '#00d4ff'); ll.position.set(-2.5,1.2,0); this.addObject(ll);
            const rl = this.createTextSprite('RIGHT', 0.4, '#a855f7'); rl.position.set(2.5,1.2,0); this.addObject(rl);
            for(let i=0; i<5; i++) { 
                const lh = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.4,16), new THREE.MeshStandardMaterial({color:0x0a0a0f}));
                lh.position.set(-2.5, 0.2, -1.2+i*0.6); lh.userData = {filled:false,index:i}; this.leftHoles.push(lh); this.addObject(lh);
                const rh = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.4,16), new THREE.MeshStandardMaterial({color:0x0a0a0f}));
                rh.position.set(2.5, 0.2, -1.2+i*0.6); rh.userData = {filled:false,index:i}; this.rightHoles.push(rh); this.addObject(rh);
                const lp = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,16), this.createGlowMaterial(0x00d4ff,0.4));
                lp.position.set(-4.2, 0.4, -1.2+i*0.6); lp.userData = {placed:false,held:false,origPos:lp.position.clone()}; this.leftPegs.push(lp); this.addObject(lp);
                const rp = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,16), this.createGlowMaterial(0xa855f7,0.4));
                rp.position.set(4.2, 0.4, -1.2+i*0.6); rp.userData = {placed:false,held:false,origPos:rp.position.clone()}; this.rightPegs.push(rp); this.addObject(rp);
            } }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.4);
            const lg = cd.left.gestures.grip?.clicked || AppState.leftGrip, rg = cd.right.gestures.grip?.clicked || AppState.rightGrip;
            if(rg && !this.lastRightGrip && !this.heldRight) { for(const p of this.rightPegs) { if(!p.userData.placed && !p.userData.held && p.position.distanceTo(wp)<0.6) { this.heldRight = p; p.userData.held = true; p.scale.set(1.3,1.3,1.3); break; } } }
            if(!rg && this.lastRightGrip && this.heldRight) { let placed = false;
                for(const h of this.rightHoles) { if(!h.userData.filled && this.heldRight.position.distanceTo(h.position)<0.5) { this.heldRight.position.copy(h.position); this.heldRight.position.y = 0.45; this.heldRight.userData.placed = true; h.userData.filled = true; this.rightCount++; placed = true; break; } }
                if(!placed) this.heldRight.position.copy(this.heldRight.userData.origPos); this.heldRight.scale.set(1,1,1); this.heldRight.userData.held = false; this.heldRight = null; }
            if(this.heldRight) { this.heldRight.position.x = Math.max(0.5, wp.x); this.heldRight.position.z = wp.z; this.heldRight.position.y = 1; }
            if(lg && !this.lastLeftGrip && !this.heldLeft) { for(const p of this.leftPegs) { if(!p.userData.placed && !p.userData.held && p.position.distanceTo(wp)<0.6) { this.heldLeft = p; p.userData.held = true; p.scale.set(1.3,1.3,1.3); break; } } }
            if(!lg && this.lastLeftGrip && this.heldLeft) { let placed = false;
                for(const h of this.leftHoles) { if(!h.userData.filled && this.heldLeft.position.distanceTo(h.position)<0.5) { this.heldLeft.position.copy(h.position); this.heldLeft.position.y = 0.45; this.heldLeft.userData.placed = true; h.userData.filled = true; this.leftCount++; placed = true; break; } }
                if(!placed) this.heldLeft.position.copy(this.heldLeft.userData.origPos); this.heldLeft.scale.set(1,1,1); this.heldLeft.userData.held = false; this.heldLeft = null; }
            if(this.heldLeft) { this.heldLeft.position.x = Math.min(-0.5, wp.x); this.heldLeft.position.z = wp.z; this.heldLeft.position.y = 1; }
            this.lastLeftGrip = lg; this.lastRightGrip = rg; this.completedPairs = Math.min(this.leftCount, this.rightCount);
            document.getElementById('score').textContent = this.completedPairs; document.getElementById('metric-1').textContent = this.leftCount + this.rightCount;
            document.getElementById('metric-2').textContent = (Math.min(this.leftCount,this.rightCount)/Math.max(this.leftCount,this.rightCount,1)*100).toFixed(0)+'%';
            this.updateTimer(); if(this.leftCount>=5 && this.rightCount>=5) showResults('purdue', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; const idx = Math.floor(this.demoTime/1.5);
            if(idx < 5) { const lp = this.leftPegs[idx], rp = this.rightPegs[idx], lh = this.leftHoles[idx], rh = this.rightHoles[idx];
                const pr = (this.demoTime % 1.5) / 1.5;
                if(lp && !lp.userData.placed) { if(pr<0.7) { lp.position.x = lp.userData.origPos.x + (lh.position.x - lp.userData.origPos.x)*pr/0.7; lp.position.y = 0.8; } else { lp.position.copy(lh.position); lp.position.y = 0.45; lp.userData.placed = true; this.leftCount++; } }
                if(rp && !rp.userData.placed) { if(pr<0.7) { rp.position.x = rp.userData.origPos.x + (rh.position.x - rp.userData.origPos.x)*pr/0.7; rp.position.y = 0.8; } else { rp.position.copy(rh.position); rp.position.y = 0.45; rp.userData.placed = true; this.rightCount++; } }
            } this.completedPairs = Math.min(this.leftCount, this.rightCount); document.getElementById('score').textContent = this.completedPairs;
            this.updateTimer(); if(this.demoTime > 10) stopAssessment(); }
        getResults() { const t = (Date.now()-AppState.startTime)/1000; return { pairs: this.completedPairs, total: this.leftCount+this.rightCount, time: t.toFixed(2), symmetry: (Math.min(this.leftCount,this.rightCount)/Math.max(this.leftCount,this.rightCount)*100).toFixed(1)+'%' }; }
    }

    // ============================================================================
    // GRIP FORCE MODULE
    // ============================================================================

/* --- MOTOR: GripForceModule (js/modules/motor/gripforce.js) --- */
    class GripForceModule extends BaseModule {
        constructor(e) { super(e); this.targetForce = 50; this.trials = []; this.trialCount = 0; this.maxTrials = 10; this.currentForce = 0; this.holdTime = 0; this.holdRequired = 1.5;
            this.forceBar = null; this.targetBar = null; this.accuracies = []; this.trialActive = false; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,2,0);
            const bg = new THREE.Mesh(new THREE.BoxGeometry(2,6,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); bg.position.set(0,3,-1); this.addObject(bg);
            this.forceBar = new THREE.Mesh(new THREE.BoxGeometry(1.5,0.1,0.3), this.createGlowMaterial(0x00ff88,0.6)); this.forceBar.position.set(0,0.5,-0.8); this.addObject(this.forceBar);
            this.targetBar = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.15,0.2), this.createGlowMaterial(0xffd700,0.8)); this.targetBar.position.set(0,3,-0.7); this.addObject(this.targetBar);
            const lbl = this.createTextSprite('MATCH THE LINE', 0.4, '#ffd700'); lbl.position.set(0,6.5,0); this.addObject(lbl);
            for(let i=0; i<=10; i++) { const tick = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.02,0.1), new THREE.MeshStandardMaterial({color:0x666666})); tick.position.set(-0.9,0.5+i*0.5,-0.7); this.addObject(tick);
                if(i%2===0) { const tl = this.createTextSprite((i*10)+'%', 0.15, '#666666'); tl.position.set(-1.3,0.5+i*0.5,-0.7); this.addObject(tl); } } }
        start(d=false) { super.start(d); this.nextTrial(); }
        nextTrial() { if(this.trialCount >= this.maxTrials) { showResults('gripforce', this.getResults()); return; }
            this.targetForce = 20 + Math.floor(Math.random()*6)*15; this.targetBar.position.y = 0.5 + (this.targetForce/100)*5; this.holdTime = 0; this.trialActive = true; }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const grip = cd.right.gestures.grip?.pull || 0; this.currentForce = grip;
            this.forceBar.position.y = 0.5 + (this.currentForce/100)*5;
            this.forceBar.material.color.setHex(Math.abs(this.currentForce - this.targetForce) < 10 ? 0x00ff88 : 0x00d4ff);
            if(this.trialActive && Math.abs(this.currentForce - this.targetForce) < 10) { this.holdTime += dt;
                if(this.holdTime >= this.holdRequired) { this.accuracies.push(100 - Math.abs(this.currentForce - this.targetForce)); this.trialCount++; this.trialActive = false;
                    document.getElementById('score').textContent = this.trialCount; document.getElementById('metric-1').textContent = (this.accuracies.reduce((a,b)=>a+b,0)/this.accuracies.length).toFixed(0)+'%';
                    setTimeout(() => this.nextTrial(), 500); }
            } else { this.holdTime = Math.max(0, this.holdTime - dt*0.5); }
            document.getElementById('metric-3').textContent = Math.abs(this.currentForce - this.targetForce).toFixed(0)+'%'; this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const cycle = this.demoTime % 3; 
            if(cycle < 0.5) { this.currentForce = this.currentForce * 0.9; }
            else if(cycle < 2) { this.currentForce += (this.targetForce - this.currentForce) * 0.05; }
            else if(cycle < 2.5 && this.trialActive) { this.accuracies.push(95); this.trialCount++; this.trialActive = false; document.getElementById('score').textContent = this.trialCount;
                this.targetForce = 20 + Math.floor(Math.random()*6)*15; this.targetBar.position.y = 0.5 + (this.targetForce/100)*5; }
            else if(cycle >= 2.8) { this.trialActive = true; }
            this.forceBar.position.y = 0.5 + (this.currentForce/100)*5; this.updateTimer(); if(this.trialCount >= 5) stopAssessment(); }
        getResults() { const avg = this.accuracies.length>0 ? this.accuracies.reduce((a,b)=>a+b,0)/this.accuracies.length : 0;
            const variance = this.accuracies.length>0 ? Math.sqrt(this.accuracies.map(x=>(x-avg)**2).reduce((a,b)=>a+b,0)/this.accuracies.length) : 0;
            return { trials: this.trialCount, accuracy: avg.toFixed(1)+'%', variability: variance.toFixed(1), avgError: (100-avg).toFixed(1)+'%' }; }
    }

    // ============================================================================
    // FINGER SEQUENCE MODULE
    // ============================================================================

/* --- MOTOR: FingerSeqModule (js/modules/motor/fingerseq.js) --- */
    class FingerSeqModule extends BaseModule {
        constructor(e) { super(e); this.sequences = [[1,2,3,4],[4,3,2,1],[1,3,2,4],[2,4,1,3],[1,2,4,3]]; this.currentSeq = []; this.seqIndex = 0; this.inputIndex = 0;
            this.correct = 0; this.errors = 0; this.seqTimes = []; this.fingerMeshes = []; this.seqStartTime = 0; }
        init() { this.engine.camera.position.set(0,6,8); this.engine.camera.lookAt(0,2,0);
            const colors = [0xff006e, 0xffd700, 0x00ff88, 0x00d4ff]; const labels = ['1','2','3','4'];
            for(let i=0; i<4; i++) { const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.3,32), this.createGlowMaterial(colors[i],0.3));
                btn.position.set(-2.25+i*1.5, 0.15, 2); btn.userData = {index:i+1, active:false}; this.fingerMeshes.push(btn); this.addObject(btn);
                const lbl = this.createTextSprite(labels[i], 0.4, '#ffffff'); lbl.position.set(-2.25+i*1.5, 0.8, 2); this.addObject(lbl); }
            const seqPanel = new THREE.Mesh(new THREE.BoxGeometry(8,1.5,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); seqPanel.position.set(0,4,-1); this.addObject(seqPanel);
            this.seqDisplay = []; for(let i=0; i<4; i++) { const box = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.1), new THREE.MeshStandardMaterial({color:0x2a2a35}));
                box.position.set(-1.5+i*1, 4, -0.8); this.seqDisplay.push(box); this.addObject(box); } }
        start(d=false) { super.start(d); this.showSequence(); }
        showSequence() { if(this.seqIndex >= this.sequences.length) { showResults('fingerseq', this.getResults()); return; }
            this.currentSeq = this.sequences[this.seqIndex]; this.inputIndex = 0;
            const colors = [0xff006e, 0xffd700, 0x00ff88, 0x00d4ff];
            this.seqDisplay.forEach((box,i) => { if(i < this.currentSeq.length) { box.material.color.setHex(colors[this.currentSeq[i]-1]); box.material.emissive = new THREE.Color(colors[this.currentSeq[i]-1]); box.material.emissiveIntensity = 0.5; } });
            this.seqStartTime = Date.now(); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.15);
            const grip = cd.right.gestures.grip?.clicked || false;
            if(grip && !this.lastGrip) { for(let i=0; i<4; i++) { if(this.fingerMeshes[i].position.distanceTo(wp) < 0.8) { this.onFingerTap(i+1); break; } } }
            this.lastGrip = grip; this.updateTimer(); }
        onFingerTap(finger) { if(this.inputIndex >= this.currentSeq.length) return;
            const expected = this.currentSeq[this.inputIndex]; this.fingerMeshes[finger-1].material.emissiveIntensity = 1;
            setTimeout(() => { this.fingerMeshes[finger-1].material.emissiveIntensity = 0.3; }, 150);
            if(finger === expected) { this.inputIndex++;
                if(this.inputIndex >= this.currentSeq.length) { this.correct++; this.seqTimes.push(Date.now() - this.seqStartTime);
                    document.getElementById('score').textContent = this.correct; document.getElementById('metric-1').textContent = this.correct;
                    if(this.seqTimes.length>0) document.getElementById('metric-3').textContent = (this.seqTimes.reduce((a,b)=>a+b,0)/this.seqTimes.length/1000).toFixed(2)+'s';
                    this.seqIndex++; setTimeout(() => this.showSequence(), 800); }
            } else { this.errors++; document.getElementById('metric-2').textContent = this.errors; this.inputIndex = 0; } }
        runDemo(dt) { this.demoTime += dt; const tapTime = 0.4; const tapIdx = Math.floor((this.demoTime % (tapTime*5)) / tapTime);
            if(tapIdx < this.currentSeq.length && tapIdx !== this.lastDemoTap) { this.onFingerTap(this.currentSeq[tapIdx]); this.lastDemoTap = tapIdx; }
            if(this.demoTime % (tapTime*5) < 0.1) this.lastDemoTap = -1;
            this.updateTimer(); if(this.correct >= 3) stopAssessment(); }
        getResults() { const avgTime = this.seqTimes.length>0 ? this.seqTimes.reduce((a,b)=>a+b,0)/this.seqTimes.length/1000 : 0;
            return { correct: this.correct, errors: this.errors, avgTime: avgTime.toFixed(2)+'s', accuracy: (this.correct/(this.correct+this.errors)*100).toFixed(1)+'%' }; }
    }

    // ============================================================================
    // GO/NO-GO MODULE
    // ============================================================================

/* --- COGNITIVE: GoNoGoModule (js/modules/cognitive/gonogo.js) --- */
    class GoNoGoModule extends BaseModule {
        constructor(e) { super(e); this.target = null; this.trialCount = 0; this.maxTrials = 30; this.hits = 0; this.falseAlarms = 0; this.misses = 0;
            this.isGo = true; this.stimulusTime = null; this.responded = false; this.reactionTimes = []; this.lastGrip = false; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,2,0);
            const bg = new THREE.Mesh(new THREE.BoxGeometry(6,4,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); bg.position.set(0,3,-1); this.addObject(bg);
            this.target = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), this.createGlowMaterial(0x00ff88,0.8)); this.target.position.set(0,3,0); this.target.visible = false; this.addObject(this.target);
            const goLbl = this.createTextSprite('GREEN = CLICK', 0.3, '#00ff88'); goLbl.position.set(-2,6,0); this.addObject(goLbl);
            const noLbl = this.createTextSprite('RED = DON\'T CLICK', 0.3, '#ff006e'); noLbl.position.set(2,6,0); this.addObject(noLbl); }
        start(d=false) { super.start(d); setTimeout(() => this.showStimulus(), 1500); }
        showStimulus() { if(this.trialCount >= this.maxTrials) { showResults('gonogo', this.getResults()); return; }
            this.isGo = Math.random() > 0.3; this.target.material.color.setHex(this.isGo ? 0x00ff88 : 0xff006e);
            this.target.material.emissive.setHex(this.isGo ? 0x00ff88 : 0xff006e); this.target.visible = true;
            this.stimulusTime = Date.now(); this.responded = false;
            setTimeout(() => { if(!this.responded) { if(this.isGo) this.misses++; this.nextTrial(); } }, 1500); }
        nextTrial() { this.target.visible = false; this.trialCount++;
            document.getElementById('score').textContent = this.hits - this.falseAlarms;
            document.getElementById('metric-1').textContent = this.hits; document.getElementById('metric-2').textContent = this.falseAlarms;
            if(this.reactionTimes.length>0) document.getElementById('metric-3').textContent = (this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length).toFixed(0)+'ms';
            if(this.trialCount < this.maxTrials) setTimeout(() => this.showStimulus(), 500 + Math.random()*1000); else showResults('gonogo', this.getResults()); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const grip = cd.right.gestures.grip?.clicked || false;
            if(grip && !this.lastGrip && this.target.visible && !this.responded) { this.responded = true;
                if(this.isGo) { this.hits++; this.reactionTimes.push(Date.now() - this.stimulusTime); } else { this.falseAlarms++; }
                this.nextTrial(); }
            this.lastGrip = grip; this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const phase = this.demoTime % 2;
            if(phase < 0.2 && !this.target.visible) this.showStimulus();
            else if(phase > 0.8 && phase < 1 && this.target.visible && !this.responded && this.isGo) { this.responded = true; this.hits++; this.reactionTimes.push(250 + Math.random()*100); this.nextTrial(); }
            else if(phase > 1.5 && this.target.visible && !this.responded) { if(this.isGo) this.misses++; this.nextTrial(); }
            this.updateTimer(); if(this.trialCount >= 15) stopAssessment(); }
        getResults() { const avgRT = this.reactionTimes.length>0 ? this.reactionTimes.reduce((a,b)=>a+b,0)/this.reactionTimes.length : 0;
            return { hits: this.hits, falseAlarms: this.falseAlarms, misses: this.misses, avgRT: avgRT.toFixed(0)+'ms', score: this.hits - this.falseAlarms }; }
    }

    // ============================================================================
    // N-BACK MODULE
    // ============================================================================

/* --- COGNITIVE: NBackModule (js/modules/cognitive/nback.js) --- */
    class NBackModule extends BaseModule {
        constructor(e) { super(e); this.n = 2; this.stimuli = []; this.currentIndex = 0; this.hits = 0; this.misses = 0; this.falseAlarms = 0; this.correctRejections = 0;
            this.shapes = ['circle','square','triangle','diamond']; this.currentShape = null; this.responded = false; this.lastGrip = false; this.shapeMesh = null; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,3,0);
            const panel = new THREE.Mesh(new THREE.BoxGeometry(5,4,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); panel.position.set(0,3,-1); this.addObject(panel);
            const lbl = this.createTextSprite('2-BACK: Match 2 steps ago?', 0.35, '#ffd700'); lbl.position.set(0,6,0); this.addObject(lbl);
            this.shapeMesh = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,0.3), this.createGlowMaterial(0x00d4ff,0.6)); this.shapeMesh.position.set(0,3,0); this.shapeMesh.visible = false; this.addObject(this.shapeMesh);
            for(let i=0; i<25; i++) { const isMatch = i >= this.n && Math.random() > 0.7;
                this.stimuli.push(isMatch ? this.stimuli[i-this.n] : this.shapes[Math.floor(Math.random()*this.shapes.length)]); } }
        start(d=false) { super.start(d); this.showStimulus(); }
        showStimulus() { if(this.currentIndex >= this.stimuli.length) { showResults('nback', this.getResults()); return; }
            this.currentShape = this.stimuli[this.currentIndex]; this.updateShapeMesh(); this.shapeMesh.visible = true; this.responded = false;
            setTimeout(() => { if(!this.responded) { const isMatch = this.currentIndex >= this.n && this.currentShape === this.stimuli[this.currentIndex - this.n];
                if(isMatch) this.misses++; else this.correctRejections++; }
                this.shapeMesh.visible = false; this.currentIndex++; this.updateMetrics();
                if(this.currentIndex < this.stimuli.length) setTimeout(() => this.showStimulus(), 500); else showResults('nback', this.getResults()); }, 2000); }
        updateShapeMesh() { const colors = {circle:0x00d4ff, square:0xa855f7, triangle:0x00ff88, diamond:0xff006e};
            this.shapeMesh.material.color.setHex(colors[this.currentShape]||0xffffff); this.shapeMesh.material.emissive.setHex(colors[this.currentShape]||0xffffff); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const grip = cd.right.gestures.grip?.clicked || false;
            if(grip && !this.lastGrip && this.shapeMesh.visible && !this.responded) { this.responded = true;
                const isMatch = this.currentIndex >= this.n && this.currentShape === this.stimuli[this.currentIndex - this.n];
                if(isMatch) this.hits++; else this.falseAlarms++; this.updateMetrics(); }
            this.lastGrip = grip; this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const phase = this.demoTime % 2.5;
            if(phase < 0.1 && !this.shapeMesh.visible && this.currentIndex < this.stimuli.length) this.showStimulus();
            else if(phase > 1 && phase < 1.2 && this.shapeMesh.visible && !this.responded) {
                const isMatch = this.currentIndex >= this.n && this.currentShape === this.stimuli[this.currentIndex - this.n];
                if(isMatch) { this.responded = true; this.hits++; this.updateMetrics(); } }
            this.updateTimer(); if(this.currentIndex >= 12) stopAssessment(); }
        updateMetrics() { document.getElementById('score').textContent = this.hits; document.getElementById('metric-1').textContent = this.hits;
            document.getElementById('metric-2').textContent = this.falseAlarms;
            const h = this.hits/(this.hits+this.misses+0.01), f = this.falseAlarms/(this.falseAlarms+this.correctRejections+0.01);
            document.getElementById('metric-3').textContent = (Math.min(3.5, Math.max(-3.5, 0.6*Math.log((h+0.01)/(1-h+0.01)) - 0.6*Math.log((f+0.01)/(1-f+0.01))))).toFixed(2); }
        getResults() { const h = this.hits/(this.hits+this.misses+0.01), f = this.falseAlarms/(this.falseAlarms+this.correctRejections+0.01);
            const dPrime = 0.6*Math.log((h+0.01)/(1-h+0.01)) - 0.6*Math.log((f+0.01)/(1-f+0.01));
            return { hits: this.hits, falseAlarms: this.falseAlarms, misses: this.misses, dPrime: Math.min(3.5, Math.max(-3.5, dPrime)).toFixed(2) }; }
    }

    // ============================================================================
    // SYMBOL DIGIT MODULE
    // ============================================================================

/* --- COGNITIVE: SymbolDigitModule (js/modules/cognitive/symboldigit.js) --- */
    class SymbolDigitModule extends BaseModule {
        constructor(e) { super(e); this.symbols = ['‚óè','‚ñ†','‚ñ≤','‚óÜ','‚òÖ','‚óé','‚ñº','‚¨ü','‚¨¢']; this.key = {}; this.currentSymbol = ''; this.correct = 0; this.errors = 0;
            this.trialCount = 0; this.maxTrials = 30; this.stimulusTime = null; this.responseTimes = []; this.buttons = []; }
        init() { this.engine.camera.position.set(0,6,10); this.engine.camera.lookAt(0,2,0);
            const shuffled = [...Array(9).keys()].sort(() => Math.random() - 0.5);
            this.symbols.forEach((s,i) => { this.key[s] = shuffled[i]+1; });
            const keyPanel = new THREE.Mesh(new THREE.BoxGeometry(10,1.5,0.2), new THREE.MeshStandardMaterial({color:0x1a1a25})); keyPanel.position.set(0,5.5,-1); this.addObject(keyPanel);
            this.symbols.forEach((s,i) => { const lbl = this.createTextSprite(s+':'+this.key[s], 0.25, '#00d4ff'); lbl.position.set(-4+i*1, 5.5, -0.5); this.addObject(lbl); });
            this.stimulusDisplay = this.createTextSprite('?', 1, '#ffffff'); this.stimulusDisplay.position.set(0, 3.5, 0); this.addObject(this.stimulusDisplay);
            for(let i=1; i<=9; i++) { const btn = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.3), this.createGlowMaterial(0x2a2a35,0.3));
                btn.position.set(-4+(i-1)*1, 1, 2); btn.userData = {digit:i}; this.buttons.push(btn); this.addObject(btn);
                const lbl = this.createTextSprite(i.toString(), 0.3, '#ffffff'); lbl.position.set(-4+(i-1)*1, 1.6, 2); this.addObject(lbl); } }
        start(d=false) { super.start(d); this.nextTrial(); }
        nextTrial() { if(this.trialCount >= this.maxTrials) { showResults('symboldigit', this.getResults()); return; }
            this.currentSymbol = this.symbols[Math.floor(Math.random()*this.symbols.length)];
            const cv = document.createElement('canvas'), ctx = cv.getContext('2d'); cv.width = 256; cv.height = 128;
            ctx.fillStyle = '#ffffff'; ctx.font = '80px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.currentSymbol, 128, 90);
            this.stimulusDisplay.material.map = new THREE.CanvasTexture(cv); this.stimulusDisplay.material.needsUpdate = true;
            this.stimulusTime = Date.now(); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 1);
            const grip = cd.right.gestures.grip?.clicked || false;
            if(grip && !this.lastGrip) { for(const btn of this.buttons) { if(btn.position.distanceTo(wp) < 0.7) { this.onResponse(btn.userData.digit); break; } } }
            this.lastGrip = grip; this.updateTimer(); }
        onResponse(digit) { const correct = this.key[this.currentSymbol] === digit;
            if(correct) { this.correct++; this.responseTimes.push(Date.now() - this.stimulusTime); } else this.errors++;
            this.trialCount++; document.getElementById('score').textContent = this.correct; document.getElementById('metric-1').textContent = this.correct;
            document.getElementById('metric-2').textContent = this.errors;
            const elapsed = (Date.now() - AppState.startTime) / 60000; document.getElementById('metric-3').textContent = (this.correct/Math.max(0.1,elapsed)).toFixed(1);
            this.nextTrial(); }
        runDemo(dt) { this.demoTime += dt; if(Math.floor(this.demoTime/1.2) > this.trialCount && this.trialCount < 15) { this.onResponse(this.key[this.currentSymbol]); }
            this.updateTimer(); if(this.trialCount >= 15) stopAssessment(); }
        getResults() { const elapsed = (Date.now() - AppState.startTime) / 60000;
            return { correct: this.correct, errors: this.errors, rate: (this.correct/Math.max(0.1,elapsed)).toFixed(1)+'/min', accuracy: (this.correct/(this.correct+this.errors)*100).toFixed(1)+'%' }; }
    }

    // ============================================================================
    // SPIRAL DRAWING MODULE
    // ============================================================================

/* --- MOVEMENT: SpiralModule (js/modules/movement/spiral.js) --- */
    class SpiralModule extends BaseModule {
        constructor(e) { super(e); this.spiralPoints = []; this.userPoints = []; this.userLine = null; this.isDrawing = false; this.smoothness = 0; this.speedDecay = 0; }
        init() { this.engine.camera.position.set(0,12,0.1); this.engine.camera.lookAt(0,0,0);
            const points = []; for(let t=0; t<6*Math.PI; t+=0.1) { const r = 0.3 + t*0.25; points.push(new THREE.Vector3(Math.cos(t)*r, 0.05, Math.sin(t)*r)); }
            this.spiralPoints = points;
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const spiral = new THREE.Line(geo, new THREE.LineBasicMaterial({color:0x00d4ff, linewidth:2})); this.addObject(spiral);
            const startMarker = new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16), this.createGlowMaterial(0x00ff88,0.8)); startMarker.position.copy(points[0]); this.addObject(startMarker);
            const endMarker = new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16), this.createGlowMaterial(0xff006e,0.8)); endMarker.position.copy(points[points.length-1]); this.addObject(endMarker);
            const lbl = this.createTextSprite('TRACE: Green to Red', 0.4, '#ffd700'); lbl.position.set(0,0.5,6); this.addObject(lbl);
            this.userLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color:0xffd700})); this.addObject(this.userLine); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const wp = this.engine.getWorldPosition(AppState.mousePos.x, AppState.mousePos.y, 0.05);
            const grip = cd.right.gestures.grip?.clicked || false;
            if(grip) { this.isDrawing = true; this.userPoints.push(new THREE.Vector3(wp.x, 0.1, wp.z));
                this.userLine.geometry.setFromPoints(this.userPoints); this.userLine.geometry.attributes.position.needsUpdate = true; }
            else if(this.isDrawing && this.userPoints.length > 10) { this.calculateMetrics(); showResults('spiral', this.getResults()); }
            this.updateTimer(); }
        runDemo(dt) { this.demoTime += dt; const idx = Math.floor(this.demoTime * 15);
            if(idx < this.spiralPoints.length) { const pt = this.spiralPoints[idx].clone();
                pt.x += (Math.random()-0.5)*0.1; pt.z += (Math.random()-0.5)*0.1; pt.y = 0.1;
                this.userPoints.push(pt); this.userLine.geometry.setFromPoints(this.userPoints); }
            this.updateTimer(); if(idx >= this.spiralPoints.length - 1) { this.calculateMetrics(); stopAssessment(); } }
        calculateMetrics() { let totalDev = 0, speeds = [];
            for(let i=0; i<this.userPoints.length; i++) { let minDist = Infinity;
                for(const sp of this.spiralPoints) { const d = this.userPoints[i].distanceTo(sp); if(d < minDist) minDist = d; }
                totalDev += minDist;
                if(i > 0) speeds.push(this.userPoints[i].distanceTo(this.userPoints[i-1])); }
            this.smoothness = Math.max(0, 100 - totalDev / this.userPoints.length * 50);
            if(speeds.length > 10) { const first = speeds.slice(0,5).reduce((a,b)=>a+b,0)/5; const last = speeds.slice(-5).reduce((a,b)=>a+b,0)/5; this.speedDecay = ((first-last)/first*100)||0; }
            document.getElementById('score').textContent = this.smoothness.toFixed(0)+'%'; }
        getResults() { return { smoothness: this.smoothness.toFixed(1)+'%', speedDecay: this.speedDecay.toFixed(1)+'%', points: this.userPoints.length }; }
    }

    // ============================================================================
    // PRONATION/SUPINATION MODULE
    // ============================================================================

/* --- MOVEMENT: PronationModule (js/modules/movement/pronation.js) --- */
    class PronationModule extends BaseModule {
        constructor(e) { super(e); this.cycles = 0; this.lastLeft = false; this.lastRight = false; this.times = []; this.lastSwitchTime = 0; this.currentSide = null; this.leftBar = null; this.rightBar = null; }
        init() { this.engine.camera.position.set(0,5,10); this.engine.camera.lookAt(0,2,0);
            this.leftBar = new THREE.Mesh(new THREE.BoxGeometry(2,3,0.5), this.createGlowMaterial(0x00d4ff,0.3)); this.leftBar.position.set(-2.5,1.5,0); this.addObject(this.leftBar);
            this.rightBar = new THREE.Mesh(new THREE.BoxGeometry(2,3,0.5), this.createGlowMaterial(0xa855f7,0.3)); this.rightBar.position.set(2.5,1.5,0); this.addObject(this.rightBar);
            const ll = this.createTextSprite('LEFT', 0.4, '#00d4ff'); ll.position.set(-2.5,4,0); this.addObject(ll);
            const rl = this.createTextSprite('RIGHT', 0.4, '#a855f7'); rl.position.set(2.5,4,0); this.addObject(rl);
            const inst = this.createTextSprite('ALTERNATE L-R-L-R...', 0.4, '#ffd700'); inst.position.set(0,5.5,0); this.addObject(inst); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const lg = cd.left.gestures.grip?.clicked || AppState.leftGrip; const rg = cd.right.gestures.grip?.clicked || AppState.rightGrip;
            this.leftBar.material.emissiveIntensity = lg ? 0.8 : 0.3; this.rightBar.material.emissiveIntensity = rg ? 0.8 : 0.3;
            if(lg && !this.lastLeft && this.currentSide !== 'left') { if(this.currentSide === 'right') { this.cycles++; this.times.push(Date.now() - this.lastSwitchTime); }
                this.currentSide = 'left'; this.lastSwitchTime = Date.now(); }
            if(rg && !this.lastRight && this.currentSide !== 'right') { if(this.currentSide === 'left') { this.cycles++; this.times.push(Date.now() - this.lastSwitchTime); }
                this.currentSide = 'right'; this.lastSwitchTime = Date.now(); }
            this.lastLeft = lg; this.lastRight = rg;
            document.getElementById('score').textContent = this.cycles; document.getElementById('metric-1').textContent = this.cycles;
            if(this.times.length > 1) { const avg = this.times.reduce((a,b)=>a+b,0)/this.times.length; const variance = Math.sqrt(this.times.map(t=>(t-avg)**2).reduce((a,b)=>a+b,0)/this.times.length);
                document.getElementById('metric-2').textContent = (100-Math.min(100,variance/5)).toFixed(0)+'%'; }
            const elapsed = (Date.now() - AppState.startTime) / 1000; document.getElementById('metric-3').textContent = (this.cycles/elapsed).toFixed(2);
            this.updateTimer(); if(elapsed > 15) showResults('pronation', this.getResults()); }
        runDemo(dt) { this.demoTime += dt; const period = 0.3; const phase = this.demoTime % period;
            const isLeft = Math.floor(this.demoTime / period) % 2 === 0;
            this.leftBar.material.emissiveIntensity = isLeft ? 0.8 : 0.3; this.rightBar.material.emissiveIntensity = isLeft ? 0.3 : 0.8;
            if(isLeft && this.currentSide !== 'left') { if(this.currentSide) this.cycles++; this.currentSide = 'left'; }
            if(!isLeft && this.currentSide !== 'right') { if(this.currentSide) this.cycles++; this.currentSide = 'right'; }
            document.getElementById('score').textContent = this.cycles; this.updateTimer(); if(this.demoTime > 8) stopAssessment(); }
        getResults() { const elapsed = (Date.now() - AppState.startTime) / 1000; const avg = this.times.length>0 ? this.times.reduce((a,b)=>a+b,0)/this.times.length : 0;
            const variance = this.times.length>1 ? Math.sqrt(this.times.map(t=>(t-avg)**2).reduce((a,b)=>a+b,0)/this.times.length) : 0;
            return { cycles: this.cycles, rate: (this.cycles/elapsed).toFixed(2)+'/s', regularity: (100-Math.min(100,variance/5)).toFixed(0)+'%', avgInterval: avg.toFixed(0)+'ms' }; }
    }

    // ============================================================================
    // POSTURAL SWAY MODULE
    // ============================================================================

/* --- MOVEMENT: PosturalSwayModule (js/modules/movement/posturalsway.js) --- */
    class PosturalSwayModule extends BaseModule {
        constructor(e) { super(e); this.positions = []; this.marker = null; this.trail = []; this.trailLine = null; }
        init() { this.engine.camera.position.set(0,10,0.1); this.engine.camera.lookAt(0,0,0);
            const platform = new THREE.Mesh(new THREE.CircleGeometry(4,64), new THREE.MeshStandardMaterial({color:0x1a1a25})); platform.rotation.x = -Math.PI/2; this.addObject(platform);
            for(let r=1; r<=3; r++) { const ring = new THREE.Mesh(new THREE.TorusGeometry(r,0.03,8,64), new THREE.MeshStandardMaterial({color:0x2a2a35})); ring.rotation.x = -Math.PI/2; ring.position.y = 0.01; this.addObject(ring); }
            const cross1 = new THREE.Mesh(new THREE.BoxGeometry(8,0.02,0.02), new THREE.MeshStandardMaterial({color:0x2a2a35})); cross1.position.y = 0.01; this.addObject(cross1);
            const cross2 = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.02,8), new THREE.MeshStandardMaterial({color:0x2a2a35})); cross2.position.y = 0.01; this.addObject(cross2);
            this.marker = new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16), this.createGlowMaterial(0x00ff88,0.8)); this.marker.position.y = 0.2; this.addObject(this.marker);
            this.trailLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color:0x00d4ff,transparent:true,opacity:0.5})); this.trailLine.position.y = 0.1; this.addObject(this.trailLine);
            const lbl = this.createTextSprite('HOLD STEADY', 0.5, '#ffd700'); lbl.position.set(0,0.5,5); this.addObject(lbl); }
        update(dt, cd) { if(this.isDemo) { this.runDemo(dt); return; } if(!this.isRunning) return;
            const lt = cd.left.trackpad, rt = cd.right.trackpad;
            const x = ((lt.x + rt.x) / 2 - 127) / 127 * 3; const z = ((lt.y + rt.y) / 2 - 127) / 127 * 3;
            this.marker.position.x = x; this.marker.position.z = z; this.positions.push({x, z});
            this.trail.push(new THREE.Vector3(x, 0, z)); if(this.trail.length > 200) this.trail.shift();
            this.trailLine.geometry.setFromPoints(this.trail);
            this.updateMetrics(); this.updateTimer(); if((Date.now() - AppState.startTime) > 30000) showResults('posturalsway', this.getResults()); }
        runDemo(dt) { this.demoTime += dt;
            const x = Math.sin(this.demoTime*2)*0.5 + Math.sin(this.demoTime*5)*0.2 + (Math.random()-0.5)*0.1;
            const z = Math.cos(this.demoTime*1.5)*0.4 + Math.cos(this.demoTime*4)*0.15 + (Math.random()-0.5)*0.1;
            this.marker.position.x = x; this.marker.position.z = z; this.positions.push({x, z});
            this.trail.push(new THREE.Vector3(x, 0, z)); if(this.trail.length > 200) this.trail.shift();
            this.trailLine.geometry.setFromPoints(this.trail);
            this.updateMetrics(); this.updateTimer(); if(this.demoTime > 15) stopAssessment(); }
        updateMetrics() { if(this.positions.length < 2) return;
            let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity, totalVel=0;
            for(let i=0; i<this.positions.length; i++) { const p = this.positions[i];
                minX = Math.min(minX,p.x); maxX = Math.max(maxX,p.x); minZ = Math.min(minZ,p.z); maxZ = Math.max(maxZ,p.z);
                if(i>0) totalVel += Math.sqrt((p.x-this.positions[i-1].x)**2 + (p.z-this.positions[i-1].z)**2); }
            const area = (maxX-minX)*(maxZ-minZ); const avgVel = totalVel/this.positions.length;
            document.getElementById('score').textContent = Math.max(0,(100-area*20)).toFixed(0)+'%';
            document.getElementById('metric-1').textContent = area.toFixed(2); document.getElementById('metric-2').textContent = avgVel.toFixed(3);
            document.getElementById('metric-3').textContent = Math.max(0,(100-area*20)).toFixed(0)+'%'; }
        getResults() { let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity, totalVel=0;
            for(let i=0; i<this.positions.length; i++) { const p = this.positions[i];
                minX = Math.min(minX,p.x); maxX = Math.max(maxX,p.x); minZ = Math.min(minZ,p.z); maxZ = Math.max(maxZ,p.z);
                if(i>0) totalVel += Math.sqrt((p.x-this.positions[i-1].x)**2 + (p.z-this.positions[i-1].z)**2); }
            const area = (maxX-minX)*(maxZ-minZ);
            return { swayArea: area.toFixed(2), avgVelocity: (totalVel/this.positions.length).toFixed(3), stability: Math.max(0,(100-area*20)).toFixed(1)+'%' }; }
    }

/* ============================================================================
   SECTION 4: APPLICATION FUNCTIONS (js/app.js)
   ============================================================================ */

let engine, connection, inputHandler;

/* ----------------------------------------------------------------------------
   Initialization
   ---------------------------------------------------------------------------- */
function init() {
    engine = new GameEngine();
    engine.init();
    engine.createAvatar();
    connection = new EteeConnection();
    inputHandler = new InputHandler();
    setupUI();
    loadAssessment('pegboard');
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    engine.render();
}

/* ----------------------------------------------------------------------------
   UI Setup
   ---------------------------------------------------------------------------- */
function setupUI() {
    // Assessment buttons
    document.querySelectorAll('.assessment-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.assessment-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            loadAssessment(btn.dataset.assessment);
        });
    });
    
    // Control buttons
    document.getElementById('btn-start').addEventListener('click', () => startAssessment(false));
    document.getElementById('btn-demo').addEventListener('click', () => startAssessment(true));
    
    document.getElementById('btn-avatar').addEventListener('click', () => {
        const btn = document.getElementById('btn-avatar');
        const frame = document.getElementById('avatar-frame');
        if (engine.avatar.visible) {
            engine.setAvatarVisible(false);
            btn.classList.remove('active');
            btn.style.background = 'rgba(255,255,255,0.1)';
            frame.classList.add('hidden');
        } else {
            engine.setAvatarVisible(true);
            btn.classList.add('active');
            btn.style.background = 'linear-gradient(135deg, #00d4ff, #a855f7)';
            frame.classList.remove('hidden');
        }
    });
    
    document.getElementById('btn-instructions').addEventListener('click', () => {
        document.getElementById('instructions-overlay').classList.add('visible');
    });
    
    document.getElementById('btn-begin').addEventListener('click', () => {
        document.getElementById('instructions-overlay').classList.remove('visible');
        startAssessment(false);
    });
    
    document.getElementById('btn-watch-demo').addEventListener('click', () => {
        document.getElementById('instructions-overlay').classList.remove('visible');
        startAssessment(true);
    });
    
    document.getElementById('btn-retry').addEventListener('click', () => {
        document.getElementById('results-overlay').classList.remove('visible');
        startAssessment(false);
    });
    
    document.getElementById('btn-next').addEventListener('click', nextAssessment);
    document.getElementById('btn-export').addEventListener('click', exportData);
    
    document.getElementById('btn-connect').addEventListener('click', () => {
        document.getElementById('connection-modal').classList.add('visible');
    });
    
    document.getElementById('btn-cancel-connect').addEventListener('click', () => {
        document.getElementById('connection-modal').classList.remove('visible');
    });
    
    document.getElementById('btn-try-connect').addEventListener('click', tryConnect);
}

/* ----------------------------------------------------------------------------
   Assessment Management
   ---------------------------------------------------------------------------- */
function loadAssessment(id) {
    AppState.currentAssessment = id;
    const info = Assessments[id];
    
    document.getElementById('assessment-title').textContent = info.name;
    document.getElementById('assessment-tag').textContent = info.tag;
    document.getElementById('instruction-icon').textContent = info.icon;
    document.getElementById('instruction-title').textContent = info.name;
    document.getElementById('clinical-ref').textContent = 'Clinical Reference: ' + info.clinicalRef;
    document.getElementById('instruction-text').textContent = info.instructions;
    document.getElementById('score-label').textContent = info.scoreLabel;
    document.getElementById('metric-1-label').textContent = info.metrics.m1;
    document.getElementById('metric-2-label').textContent = info.metrics.m2;
    document.getElementById('metric-3-label').textContent = info.metrics.m3;
    
    document.getElementById('score').textContent = '0';
    document.getElementById('metric-1').textContent = '--';
    document.getElementById('metric-2').textContent = '--';
    document.getElementById('metric-3').textContent = '--';
    document.getElementById('timer').textContent = '00:00';
    
    engine.loadAssessment(id);
}

function startAssessment(isDemo) {
    AppState.isRunning = true;
    AppState.isDemo = isDemo;
    
    document.getElementById('game-hud').style.display = 'block';
    document.getElementById('demo-controls').style.display = AppState.demoMode ? 'block' : 'none';
    document.getElementById('instructions-overlay').classList.remove('visible');
    document.getElementById('results-overlay').classList.remove('visible');
    
    engine.currentModule.start(isDemo);
    
    document.getElementById('btn-start').textContent = '‚èπ Stop';
    document.getElementById('btn-start').onclick = stopAssessment;
    document.getElementById('btn-demo').style.display = 'none';
}

function stopAssessment() {
    if (!AppState.isRunning) return;
    AppState.isRunning = false;
    engine.currentModule.stop();
    
    document.getElementById('btn-start').textContent = 'Start Assessment';
    document.getElementById('btn-start').onclick = () => startAssessment(false);
    document.getElementById('btn-demo').style.display = 'inline-block';
}

/* ----------------------------------------------------------------------------
   Results Display
   ---------------------------------------------------------------------------- */
function showResults(id, results) {
    stopAssessment();
    const info = Assessments[id];
    document.getElementById('result-name').textContent = info.name;
    
    const grid = document.getElementById('results-grid');
    grid.innerHTML = '';
    const items = [];
    
    if (id === 'pegboard') items.push({label: 'Pegs Placed', value: results.pegsPlaced, cls: 'primary'}, {label: 'Total Time', value: results.totalTime + 's', cls: 'success'}, {label: 'Avg Peg Time', value: results.avgPegTime + 's', cls: 'warning'});
    else if (id === 'fingertap') items.push({label: 'Tap Count', value: results.tapCount, cls: 'primary'}, {label: 'Avg Amplitude', value: results.avgAmplitude, cls: 'success'}, {label: 'Decrement', value: results.decrement, cls: 'warning'});
    else if (id === 'boxblock') items.push({label: 'Transferred', value: results.blocksTransferred, cls: 'primary'}, {label: 'Total Time', value: results.totalTime + 's', cls: 'success'}, {label: 'Blocks/Min', value: results.blocksPerMinute, cls: 'warning'});
    else if (id === 'trailmaking') items.push({label: 'Connected', value: results.completed, cls: 'primary'}, {label: 'Total Time', value: results.totalTime + 's', cls: 'success'}, {label: 'Errors', value: results.errors, cls: 'warning'});
    else if (id === 'reactiontime') items.push({label: 'Trials', value: results.trials, cls: 'primary'}, {label: 'Avg RT', value: results.avgRT + 'ms', cls: 'success'}, {label: 'Best RT', value: results.minRT + 'ms', cls: 'warning'});
    else if (id === 'stroop') items.push({label: 'Correct', value: results.correct + '/' + results.total, cls: 'primary'}, {label: 'Accuracy', value: results.accuracy, cls: 'success'}, {label: 'Avg RT', value: results.avgRT + 'ms', cls: 'warning'});
    else if (id === 'tremor') items.push({label: 'Stability', value: results.stability, cls: 'primary'}, {label: 'Avg Deviation', value: results.avgDeviation, cls: 'success'}, {label: 'Frequency', value: results.frequency, cls: 'warning'});
    else if (id === 'coordination') items.push({label: 'Sync Score', value: results.avgSync, cls: 'primary'}, {label: 'Samples', value: results.samples, cls: 'success'}, {label: 'Duration', value: '30s', cls: 'warning'});
    else if (id === 'rhythmslash') items.push({label: 'Score', value: results.score, cls: 'primary'}, {label: 'Accuracy', value: results.accuracy, cls: 'success'}, {label: 'Max Combo', value: results.maxCombo + 'x', cls: 'warning'});
    else if (id === 'colorsort') items.push({label: 'Score', value: results.score, cls: 'primary'}, {label: 'Accuracy', value: results.accuracy, cls: 'success'}, {label: 'Memory Errors', value: results.memoryErrors, cls: 'warning'});
    else if (id === 'memorymatch') items.push({label: 'Pairs Found', value: results.matchedPairs, cls: 'primary'}, {label: 'Accuracy', value: results.accuracy, cls: 'success'}, {label: 'Attempts', value: results.attempts, cls: 'warning'});
    else if (id === 'towerstack') items.push({label: 'Blocks', value: results.blocksPlaced, cls: 'primary'}, {label: 'Max Height', value: results.maxHeight, cls: 'success'}, {label: 'Accuracy', value: results.avgAccuracy, cls: 'warning'});
    else if (id === 'patternrunner') items.push({label: 'Score', value: results.score, cls: 'primary'}, {label: 'Max Sequence', value: results.maxSequence, cls: 'success'}, {label: 'Errors', value: results.errors, cls: 'warning'});
    else if (id === 'whackamole') items.push({label: 'Score', value: results.score, cls: 'primary'}, {label: 'Accuracy', value: results.accuracy, cls: 'success'}, {label: 'Avg RT', value: results.avgReactionTime, cls: 'warning'});
    else if (id === 'balanceboard') items.push({label: 'Score', value: results.score, cls: 'primary'}, {label: 'Targets Hit', value: results.targetsHit, cls: 'success'}, {label: 'Stability', value: results.avgStability, cls: 'warning'});
    
    items.forEach(item => {
        const div = document.createElement('div');
        div.className = 'result-item ' + item.cls;
        div.innerHTML = '<div class="value">' + item.value + '</div><div class="label">' + item.label + '</div>';
        grid.appendChild(div);
    });
    
    document.getElementById('interpretation-text').textContent = getClinicalInterpretation(id, results);
    document.getElementById('results-overlay').classList.add('visible');
}

/* ----------------------------------------------------------------------------
   Clinical Interpretations
   ---------------------------------------------------------------------------- */
function getClinicalInterpretation(id, r) {
    if (id === 'pegboard') return parseFloat(r.totalTime) < 20 ? 'Performance within normal range. Average healthy adults complete in 18-20 seconds.' : 'May indicate reduced dexterity. Further clinical evaluation recommended.';
    if (id === 'fingertap') return parseFloat(r.decrement) < 15 ? 'Normal tapping with minimal amplitude decrement. No signs of bradykinesia.' : 'Amplitude decrement detected. May indicate early bradykinesia.';
    if (id === 'reactiontime') return parseInt(r.avgRT) < 300 ? 'Excellent reaction time within normal range (200-300ms).' : 'Elevated reaction time. Consider cognitive screening.';
    
    if (id === 'rhythmslash') {
        const acc = parseFloat(r.accuracy);
        const sym = parseFloat(r.symmetry);
        if (acc > 85 && sym > 80) return 'Excellent performance! Good reaction time, coordination, and bilateral symmetry.';
        if (acc > 70) return 'Good performance. ' + (sym < 70 ? 'Note: Asymmetry detected between hands - may indicate lateralized motor differences.' : 'Bilateral coordination is balanced.');
        return 'Performance below expected. May indicate reduced processing speed, reaction time, or motor coordination.';
    }
    
    if (id === 'colorsort') {
        const acc = parseFloat(r.accuracy);
        const memErr = r.memoryErrors;
        if (acc > 85 && memErr === 0) return 'Excellent performance! Strong working memory, attention, and cognitive flexibility.';
        if (acc > 70 && memErr <= 2) return 'Good performance. ' + (memErr > 0 ? 'Minor working memory lapses detected - ' + memErr + ' repeat recognition errors.' : 'Accurate color-repeat recognition.');
        if (memErr > 3) return 'Elevated memory errors (' + memErr + ') suggest working memory difficulties. Consider follow-up assessment.';
        return 'Performance below expected. May indicate attention, working memory, or processing speed difficulties.';
    }
    
    if (id === 'memorymatch') {
        const acc = parseFloat(r.accuracy);
        if (acc > 80) return 'Excellent visual memory! Efficient pattern recognition and spatial recall.';
        if (acc > 60) return 'Good visual memory performance. Some repeated attempts suggest minor encoding difficulties.';
        return 'Visual memory performance below expected. May indicate difficulties with visual encoding or retrieval.';
    }
    
    if (id === 'towerstack') {
        const acc = parseFloat(r.avgAccuracy);
        const falls = r.blocksFallen;
        if (acc > 80 && falls <= 1) return 'Excellent motor planning and timing! Precise visuomotor control.';
        if (acc > 60) return 'Good motor control. ' + (falls > 2 ? 'Multiple misses suggest timing difficulties under pressure.' : 'Adequate precision under increasing speed.');
        return 'Motor planning difficulties observed. May indicate visuomotor integration or timing issues.';
    }
    
    if (id === 'patternrunner') {
        const maxSeq = r.maxSequence;
        const errors = r.errors;
        if (maxSeq >= 7 && errors <= 1) return 'Excellent sequential memory! Strong procedural learning capacity.';
        if (maxSeq >= 5) return 'Good sequential memory. ' + (errors > 2 ? 'Errors suggest working memory load limitations.' : 'Adequate pattern retention.');
        return 'Sequential memory below expected. May indicate procedural memory or attention difficulties.';
    }
    
    if (id === 'whackamole') {
        const acc = parseFloat(r.accuracy);
        const avgRT = parseFloat(r.avgReactionTime);
        if (acc > 85 && avgRT < 500) return 'Excellent sustained attention and reaction time! Fast, accurate target acquisition.';
        if (acc > 70) return 'Good vigilance performance. ' + (avgRT > 600 ? 'Reaction times suggest cautious response style.' : 'Adequate speed-accuracy balance.');
        return 'Attention/vigilance below expected. May indicate sustained attention difficulties or slowed processing.';
    }
    
    if (id === 'balanceboard') {
        const targets = r.targetsHit;
        const stability = parseFloat(r.avgStability);
        const falls = r.fallOffs;
        if (targets >= 7 && stability > 80) return 'Excellent dynamic balance and fine motor control! Precise postural adjustments.';
        if (targets >= 5 && falls <= 2) return 'Good balance performance. ' + (stability < 70 ? 'Some instability noted - consider vestibular assessment.' : 'Adequate postural control.');
        return 'Balance difficulties observed. May indicate vestibular, proprioceptive, or motor control issues.';
    }
    
    return 'Results recorded. Compare with baseline measurements to track changes over time.';
}

/* ----------------------------------------------------------------------------
   Utility Functions
   ---------------------------------------------------------------------------- */
function nextAssessment() {
    document.getElementById('results-overlay').classList.remove('visible');
    const ids = Object.keys(Assessments);
    const ni = (ids.indexOf(AppState.currentAssessment) + 1) % ids.length;
    document.querySelectorAll('.assessment-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.assessment === ids[ni]);
    });
    loadAssessment(ids[ni]);
}

function exportData() {
    const data = {
        timestamp: new Date().toISOString(),
        assessment: AppState.currentAssessment,
        demoMode: AppState.demoMode,
        results: engine.currentModule.getResults()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'neuroplay_' + AppState.currentAssessment + '_' + Date.now() + '.json';
    a.click();
}

async function tryConnect() {
    const url = document.getElementById('server-address').value;
    const msgEl = document.getElementById('connection-msg');
    msgEl.className = 'connection-status-msg';
    msgEl.textContent = 'Connecting...';
    msgEl.style.display = 'block';
    
    try {
        await connection.connect(url);
        msgEl.className = 'connection-status-msg success';
        msgEl.textContent = 'Connected!';
        setTimeout(() => {
            document.getElementById('connection-modal').classList.remove('visible');
            msgEl.style.display = 'none';
        }, 1000);
    } catch (e) {
        msgEl.className = 'connection-status-msg error';
        msgEl.textContent = 'Failed: ' + e.message;
    }
}

/* ============================================================================
   INITIALIZATION
   ============================================================================ */
document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
